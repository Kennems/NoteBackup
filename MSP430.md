# MSP430

### 呼吸灯

```c
#include<msp430.h>
int main(void)
{
	WDTCTL = WDTPW | WDTHOLD;
	unsigned int de1,de2,deley,i;
	i=0;
	de1=0;
	de2=500-de1;
	P1DIR=0x01;
	while(1)
	{
		if(i==0)
		{
			P1OUT=0x01;
			for(deley=0;deley<de1;deley++)
			{
				if(de1!=500)
					de1++;
				if(de1==500)
					i=1;
			}
			P1OUT=0x00;
			for(deley=0;deley<de2;deley++);
		}
		if(i==1)
		{
			P1OUT=0x01;
			for(deley=0;deley<de1;deley++)
			{
				if(de1!=0)
					de1--;
				if(de1==0)
					i=0;
			}
			P1OUT=0x00;
			for(deley=0;deley<de2;deley++);
		}
	}
}

```

### SMCLK ： 1Mhz控制LED灯一秒闪烁一次

```c
#include <msp430.h> 
 
#define CPU_F ((double)1000000)
#define delay_us(x) __delay_cycles((long)(CPU_F*(double)x/1000000.0))
#define delay_ms(x) __delay_cycles((long)(CPU_F*(double)x/1000.0))
 
unsigned char count=0;
 
int main(void)//定时器口中断控制函数
{
 
	WDTCTL = WDTPW | WDTHOLD;	// stop watchdog timer
	P1DIR |= BIT0;              //P1.0置为输出
	TA0CCTL0 = CCIE;            //CCR0中断使能
	TA0CCR0 = 50000;            //设定计数值
	TA0CTL =TASSEL_2+MC_1+TACLR;//SMCLK，增计数模式，清除TAR
	_bis_SR_register(LPM0_bits+GIE);//低功耗模式0，使能中断
}
 
#pragma vector=TIMER0_A0_VECTOR
__interrupt void TIMER0_A0_ISR(void)
{
    count++;
    if(count==20)
    {
     count=0;
     P1OUT ^= BIT0;                          //1s改变LED1灯状态
    }
}
```

```c
//main.c
#include <oled.h>
#include"MSP430.h"
#include"bmp.h"

#define IDLE 0
#define BUSY 1

#define CPU_F                               ((double)1000000)
#define delay_us(x)                       __delay_cycles((long)(CPU_F*(double)x/1000000.0))
#define delay_ms(x)                       __delay_cycles((long)(CPU_F*(double)x/1000.0))

unsigned int t,one,ten,hund,i=0,j=0,k=0;
unsigned int pwm,ADC10_Result;
char Temper[7];
char PWM[5];
char Vol[7];

void IO_init()
{
    //IO方向调整，包括OLED屏幕和LED灯
    P2DIR |= BIT4+BIT5;
    P3DIR |= BIT0 + BIT1 + BIT6 + BIT7;

    //LED点亮
//    P3OUT &= ~BIT1;
//    P3OUT &= ~BIT0;

//    //Timer初始化
//    // 设置P3.3引脚为外设功能
//    P3SEL |= BIT2;
//    // 将P3.3引脚设置为输出模式
//    P3DIR |= BIT2;  // P3.3作为输出
//    // 将P3.4引脚设置为输入模式
//    P3DIR &= ~BIT3; // P3.4作为输入
}

void ADC_init(){
    ADC10CTL1 |= CONSEQ_2; //单通道重复采样模式
    ADC10CTL0 |= SREF_1+REFON+REF2_5V;//选择内部参考源 2.5V，打开基准源
    ADC10CTL0 |= ADC10SHT_3+MSC; //过采样率设置为 64 个采样周期，打开 AD 转换
    ADC10CTL1|= ADC10SSEL_1+ADC10DIV_1+SHS_0; //ACLK2 分 频 为 采 样 时 钟 ， 用ADC10SC 触发采集
    ADC10CTL1 |=INCH_3; //选择通道 A1
    ADC10CTL0 |= ADC10ON; //开启 ADC10
    ADC10AE0 |= BIT0; //开启外部通道 A1
}

void Timer_A1_2_init()    // TA1.2输出PWM
{
    TA1CTL |= TASSEL_1 + MC_1;    // 选择ACLK作为时钟源，增计数模式
    TA1CCTL2 = OUTMOD_7;         // 设置输出模式为复位/置位模式
    TA1CCR0 = 50;                // 设置时钟频率为32768Hz，波形频率为32768 / CCR0 ≈ 199Hz
    TA1CCR2 = 20;                // 设置占空比为CCR2 / CCR0 = 1 / 4
}


void Voltage(){
    int l;
    for(l=0;l<20;l++)
    {
     ADC10CTL0 |=ENC+ADC10SC; //开始转换
     while((ADC10CTL0 &ADC10IFG)==0); //等待 ADC10IFG 标志变高（转换完成）
     ADC10_Result+=ADC10MEM; //读取采样结果
    }
    ADC10_Result= ADC10_Result/25/1023*0.48*1000;
    Vol[0]=' '; Vol[6]='0';
    Vol[1]=ADC10_Result/1000+'0';
    Vol[2]='.';
    Vol[2]=ADC10_Result/100%10+'0';
    Vol[3]=ADC10_Result/10%10+'0';
    Vol[4]=ADC10_Result%10+'0';
    Vol[5]='V';
    SCREEN_P6x8Str(0,4," Voltage:");
    SCREEN_P6x8Str(80,4,Vol);
}

void Motor_PWM(){
    if(t < 300)     // 如果温度小于300
    {
        TA1CCR2 = 0;          // 设置占空比为0，关闭 PWM 输出
        pwm = 0;              // 设置 pwm 值为0
    }
    else if(t < 305)     // 如果温度小于305
    {
        TA1CCR2 = 20;         // 设置占空比为20，占空比为 1/4
        pwm = 2000/50;        // 设置 pwm 值为2000/50
    }
    else if(t < 310)     // 如果温度小于310
    {
        TA1CCR2 = 25;         // 设置占空比为25，占空比为 1/2.5
        pwm = 2500/50;        // 设置 pwm 值为2500/50
    }
    else if(t < 315)     // 如果温度小于315
    {
        TA1CCR2 = 30;         // 设置占空比为30，占空比为 1/1.67
        pwm = 3000/50;        // 设置 pwm 值为3000/50
    }
    else if(t < 320)     // 如果温度小于320
    {
        TA1CCR2 = 35;         // 设置占空比为35，占空比为 1/1.43
        pwm = 3500/50;        // 设置 pwm 值为3500/50
    }
    else if(t < 325)     // 如果温度小于325
    {
        TA1CCR2 = 40;         // 设置占空比为40，占空比为 1/1.25
        pwm = 4000/50;        // 设置 pwm 值为4000/50
    }
    else if(t < 330)     // 如果温度小于330
    {
        TA1CCR2 = 45;         // 设置占空比为45，占空比为 1/1.11
        pwm = 4500/50;        // 设置 pwm 值为4500/50
    }
    else                        // 其他情况（温度大于等于330）
    {
        TA1CCR2 = 50;         // 设置占空比为50，占空比为 1/1
        pwm = 5000/50;        // 设置 pwm 值为5000/50
    }
    PWM[0]=' '; PWM[5]=' ';
    PWM[1]=pwm/100+'0';
    PWM[2]=pwm/10%10+'0';
    PWM[3]=pwm%10+'0';
    PWM[4]='%';
    SCREEN_P6x8Str(0,5," PWM:");
    SCREEN_P6x8Str(80,5,PWM);
}

void main(void)
{
    WDTCTL = WDTPW + WDTHOLD;//停止看门狗
    
    //IO方向调整，包括OLED屏幕和LED灯
    P2DIR |= BIT4+BIT5;
    P3DIR |= BIT0 + BIT1 + BIT6 + BIT7;
    
    SCREEN_Init();
    SCREEN_DLY_ms(5000); // 延时5000毫秒
    SCREEN_Init();

//    IO_init();
//    ADC_init();
//    Timer_A1_2_init();
    while(1)
    {
//        SetSCREEN(1,0);
//        SetSCREEN(2,0);
//        SetSCREEN(6,0);
//        SetSCREEN(7,0);

//        //Temper
//        t = get_one_temperature();
//        Temper[0]=' ';
//        Temper[5]='C';
//        Temper[6]=' ';
//        one = t % 10;
//        Temper[4]= (char)(one + '0');
//        Temper[3]= '.';
//        ten = t / 10 % 10 ;
//        Temper[2]= (char)(ten + '0');
//        hund = t/100;
//        Temper[1]= (char)(hund + '0');
        SCREEN_P6x8Str(0,2," Temperature:");
        SCREEN_P6x8Str(0,0," Temperature:");
        SCREEN_P6x8Str(0,3," Temperature:");
//        SCREEN_P6x8Str(80,3,Temper);

//        //Voltage
//        Voltage();
//
//        //电机驱动
//        Motor_PWM();
    }
}

```

LED屏幕问题：CS置低为选择。
