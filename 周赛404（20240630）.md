# 周赛404（20240630）

## 第四题 100318. 合并两棵树后的最小直径](https://leetcode.cn/contest/weekly-contest-404/problems/find-minimum-diameter-after-merging-two-trees/)

### **题意**：

给出两棵树，现在需要在两棵树之间连一条边，求组成的新树的最小直径。

### 思路：

首先需要得出树的直径， 树的直径可以[由两次DFS/BFS或者树型DP来求](https://oi-wiki.org/graph/tree-diameter/#%E5%81%9A%E6%B3%95-1-%E4%B8%A4%E6%AC%A1-dfs)。

新树的直径有三种情况：

- **第一种**：如图，添加一条边后，例如`树2 `的`0` 连接`树1`的 `0`，`1`，`3`， 最小直径仍然可以是`树1`的半径。

![image-20240630115905034](https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240630115905034.png)

- **第二种**：两个树交换位置，同情况一。
- **第三种**：如图，添加一条边后，直径一定比树1和树2的直径都大，此时我们需要在`树1`和`树2`中选择直径中最中间的点获得两个最小的半径d1和d2，此时的最小直径为 ： $d_1 + 1 + d_2$

![image-20240630123105076](https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240630123105076.png)

三种情况取最大值，即可以获取的直径最小值

```py
class Solution:
    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:
        def get(edges):
            n = len(edges)
            g = defaultdict(list)
            for u, v in edges:
                g[u].append(v)
                g[v].append(u)
            
            d1, d2 = [0]*(n+1), [0]*(n+1)
            d = 0
                
            def dfs(u, fa): # 树形DP方法求树的直径
                for v in g[u]:
                    if v==fa:
                        continue
                    dfs(v, u)
                    t = d1[v] + 1
                    if t>d1[u]:
                        d2[u], d1[u] = d1[u], t
                    elif t>d2[u]:
                        d2[u] = t
                    nonlocal d
                    d = max(d1[u]+d2[u], d)

            dfs(0, -1)

            r = (d + 1) // 2
            return d, r

        
        d1, r1, d2, r2 = 0, 0, 0, 0

        if edges1:
            d1, r1 = get(edges1)
        if edges2:
            d2, r2 = get(edges2)

        res = max(d1, d2, r1 + r2 + 1)
        return res
```

