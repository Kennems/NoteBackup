# 第二天作业

作业内容

![image-20240707175223185](https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240707175223185.png)

## 1、打印四种启动模式启动Activity的生命周期并总结

**准备工作**：

![image-20240707202436034](https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240707202436034.png)

创建三个`Activity`文件，分别为`FirstActivity`， `SecondActivity`， `ThirdActivity`。并且在每个`Activity`文件中均在声明周期中打出Log信息。三个`Activity`都有一个`Button`， 由`FirstActivity`跳转`SecondActivity`， `SecondActivity`跳转`ThirdActivity`， `ThirdActivity`再跳转为`SecondActivity`。

### Standard

Standard是默认的启动模式，可以不设置，也可以在`AndroidManifest.xml`文件中配置

![image-20240707202809398](https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240707202809398.png)

启动`FirstActivity`：

**录制视频与截图**：

[./录制MP4视频/Standard.mp4](./录制MP4视频/Standard.mp4)

<video src="./录制MP4视频/Standard.mp4" controls style="width: 100%; height: auto;"></video>

![image-20240707204346710](https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240707204346710.png)

### 总结：

在Standard模式下，不管怎样都会新建activity，无论需要跳转的Avtivity是否已经存在方法栈内，都会创建一个新的Activity。

并且两个不同的`activity`跳转过程的声明周期流程为：

![image-20240707210625817](https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240707210625817.png) 即:

**场景一**：从First跳转到Second， 从上面视频可以看出

1. First先调用`onPause()`，页面仍是First， 但不可交互
2. Second调用`onCreate()`
3. Second调用`onStart()`
4. Second调用`onResume()`
5. First再调用`onStop()`，此时不可见也不可执行，变为可见也可执行的Second

**场景二**：从Frist跳转到Second，但是Second是透明的， 如下图

![image-20240707232329023](https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240707232329023.png)

1. First先调用`onPause()`，页面仍是First， 但不可交互
2. Second调用`onCreate()`
3. Second调用`onStart()`
4. Second调用`onResume()`
5. 此时Second可见也可交互，**但是First并没有`onStop()`**, 即仍然可见。

**场景三**： B页面关闭，重新回到A页面， 从上面视频可以看出

1. Second先调用`onPause()`，页面仍是Second， 但不可交互
2. First调用`onRestart()`
3. First调用`onStart()`
4. First调用`onResume()`
5. Second调用`onStop()`, 此时Second不可见，First可见
6. Second调用`onDestroy()`

### singleTop

同样，可以选择在`AndroidManifest.xml`修改选项`android:launchMode="singleTop"`， 或者在代码中动态设置：

```java
                Intent intent = new Intent(this, SecondActivity.class);
                intent.setFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP);
                startActivity(intent);
```

这里将三个Activity的启动模式均设置为`singleTop`类型。

**录制视频与截图**：

保持跳转顺序 `1->2`, `2->3`, `3->2`

[./录制MP4视频/SingleTop_1.mp4](./录制MP4视频/SingleTop_1.mp4)

<video src="./录制MP4视频/SingleTop_1.mp4" controls style="width: 100%; height: auto;"></video>

此时Activity的声明周期与Standard模式一样，因为在跳转时，需要跳转的页面均不在任务栈栈顶，所以每次都会创建一个新的Activity并跳转。

改变跳转顺序为：`1->2`, `2->3`, `3->3`

[./录制MP4视频/SingleTop_2.mp4](./录制MP4视频/SingleTop_2.mp4)

<video src="./录制MP4视频/SingleTop_2.mp4" controls style="width: 100%; height: auto;"></video>

此时的第三次跳转不会再创建新的Activity， 因为`ThirdActivity`在任务栈栈顶，所以会重新使用栈顶的`ThirdActivity`


### 总结：

在singleTop模式下，如果栈顶已经有该Activity的实例，就不会创建新的实例，而是复用当前的实例，并调用其`onNewIntent()`方法。如果栈顶没有该Activity的实例，则会新建一个实例。

**场景一**：从First跳转到Second，Second已经在栈顶

1. Second调用`onNewIntent()`，不会新建实例。
2. 生命周期方法不会调用，保持当前状态。

**场景二**：从First跳转到Second，Second不在栈顶

1. 按照Standard模式流程创建新的实例。

### singleTask

保持跳转顺序 `1->2`, `2->3`, `3->2`

[./录制MP4视频/SingleTask.mp4](./录制MP4视频/SingleTask.mp4)

<video src="./录制MP4视频/SingleTask.mp4" controls style="width: 100%; height: auto;"></video>

### 总结：

在singleTask模式下，如果有一个实例已经存在于任务栈中，则会把它上面的所有Activity都移除，并把这个实例置于栈顶。

**场景一**：从First跳转到Second，Second已经存在于栈中

1. 所有在Second之上的Activity会被销毁。
2. Second实例被复用，调用`onNewIntent()`方法。

**场景二**：从First跳转到Second，Second不在栈中

1. 按照Standard模式流程创建新的实例。

### singleInstance

[./录制MP4视频/SingleInstance.mp4](./录制MP4视频/SingleInstance.mp4)

<video src="./录制MP4视频/SingleInstance.mp4" controls style="width: 100%; height: auto;"></video>

### 总结：

在singleInstance模式下，该Activity会独占一个新的任务栈，并且这个任务栈中只能有这个Activity的实例。

**场景一**：从First跳转到Second

1. Second会独占一个新的任务栈。
2. 任何跳转到Second的请求都会复用这个任务栈中的实例。

## 2、打印`startService`和`bindService`生命周期并总结

**准备工作**：

![image-20240707220015442](https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240707220015442.png)

修改`AndroidManifest.xml`：

```xml
        <service
            android:name=".day2.service.MyService"
            android:enabled="true"
            android:exported="true" />
```

### startService

[./录制MP4视频/startService.mp4](./录制MP4视频/startService.mp4)

<video src="./录制MP4视频/startService.mp4" controls style="width: 100%; height: auto;"></video>

### 总结

#### startService

`startService`方法用于启动一个服务。当我们调用`startService`时，系统会调用服务的`onCreate()`方法来创建服务，然后调用`onStartCommand()`方法来执行具体的服务操作。服务一旦启动，通常会一直运行，直到通过`stopService`或`stopSelf`明确停止服务。

#### 生命周期：

1. **onCreate()**：当服务首次创建时调用。此方法只会被调用一次，用于初始化服务。
2. **onStartCommand()**：每次通过`startService`方法启动服务时都会调用此方法。此方法可以多次被调用。
3. **onDestroy()**：当服务被销毁时调用。此方法用于清理资源。

### bindService

[./录制MP4视频/bindService.mp4](./录制MP4视频/bindService.mp4)

<video src="./录制MP4视频/bindService.mp4" controls style="width: 100%; height: auto;"></video>

### 总结

#### bindService

`bindService`方法用于绑定一个服务，通常用于与服务进行交互。当我们调用`bindService`时，系统会调用服务的`onCreate()`方法来创建服务，然后调用`onBind()`方法返回一个IBinder对象，供客户端与服务交互。

#### 生命周期：

1. **onCreate()**：当服务首次创建时调用。此方法只会被调用一次，用于初始化服务。
2. **onBind()**：每次通过`bindService`方法绑定服务时都会调用此方法，并返回IBinder对象。
3. **onUnbind()**：当所有客户端都解除绑定时调用此方法。
4. **onDestroy()**：当服务不再被使用且被销毁时调用。

### startService和bindService区别：

- `startService`用于启动服务，服务会一直运行直到明确停止。适用于需要长期运行的后台任务。
- `bindService`用于绑定服务，客户端与服务交互时使用。当所有客户端解除绑定后，服务会被销毁。适用于需要与服务交互的情况。

## 3、分别使用动态注册和静态注册广播，并接受广播日志

**准备工作**：

![image-20240707222035680](https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240707222035680.png)

### 静态注册广播

静态注册广播是通过在`AndroidManifest.xml`文件中声明广播接收者（Receiver）和意图过滤器（Intent Filter）来实现的。静态注册的广播接收者即使在应用未运行时也能接收广播。

静态注册广播需要修改`AndroidManifest.xml`文件， 添加如下内容：

```xml
        <receiver
            android:name=".day2.receiver.MyBroadCastReceiver"
            android:exported="true">
            <intent-filter>
                <action android:name="myFirstBroadCast" />
            </intent-filter>
        </receiver>
```

![image-20240707222621299](https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240707222621299.png)

静态注册的意图声明Action即为在`AndroidManifest.xml`文件中的action的name。

[./录制MP4视频/staticBroadCast.mp4](./录制MP4视频/staticBroadCast.mp4)

<video src="./录制MP4视频/staticBroadCast.mp4" controls style="width: 100%; height: auto;"></video>

### 动态注册广播

动态注册广播需要在代码中注册和注销广播接收者，通常在Activity或Service的生命周期中进行。动态注册广播需要一个处于活跃状态的广播接受者，这里我用`BroadCastReceiverActivity`跳转到发送广播的Activity ：`BroadCastOperationActivity`， 这样可以保证`BroadCastReceiverActivity`处于活跃状态, 并在`onDestroy`中进行注销广播接收器。

![image-20240707223012665](https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240707223012665.png)

![image-20240707233612131](https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240707233612131.png)

之后在`MyBroadCastReceiver`中根据接收者的`IntentFilter`中的action接受广播。

![image-20240707225743534](https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240707225743534.png)

[./录制MP4视频/dynamicBroadCast.mp4](./录制MP4视频/dynamicBroadCast.mp4)

<video src="./录制MP4视频/dynamicBroadCast.mp4" controls style="width: 100%; height: auto;"></video>

### 对比总结

**静态注册广播**：在`AndroidManifest.xml`文件中声明。即使应用未运行，依然能够接收广播。适用于全局事件响应。

**动态注册广播**：在代码中注册和注销。只有在应用处于活跃状态时才能接收广播。适用于与用户交互相关的事件，可以避免不必要的资源占用。

