# 第十天作业

![image-20240715165146498](https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240715165146498.png)

## 1、完成以下2种类型的内存泄露场景，使用`LeakCanary`检测原因，通过注释标注解法

### (1) 静态变量/单例引用Activity导致的内存泄露

#### **准备工作**：

**准备的类**：

- `FirstActivity`：启动并导航到`SecondActivity`。
- `SecondActivity`：导致内存泄漏的Activity。
- `ActivitySingleton`：持有对Activity的静态引用。

**使用LeakCanary检测内存泄漏**：

- 在`build.gradle`中添加LeakCanary依赖。
- 在`Application`类中初始化LeakCanary。
- 运行应用并导航到`SecondActivity`，观察LeakCanary的内存泄漏报告。

**解决内存泄漏的方法**：

- 在`SecondActivity`的`onDestroy`方法中清除`ActivitySingleton`对Activity的引用。
- 修改`ActivitySingleton`类，添加清除引用的方法。
- 在代码中添加注释，解释清除引用的原因和方法。

![image-20240715193119481](https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240715193119481.png)

#### `LeakCanary`检测内存泄漏原因:

![image-20240715194451341](https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240715194451341.png)

![image-20240715194621641](https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240715194621641.png)

#### **录制视频**：

**内存泄漏**：

[./录制MP4视频/Leak_1_before.mp4](./录制MP4视频/Leak_1_before.mp4)

<video src="./录制MP4视频/Leak_1_before.mp4" controls style="width: 100%; height: auto;"></video>

**修复之后**：

[./录制MP4视频/Leak_1_after.mp4](./录制MP4视频/Leak_1_after.mp4)

<video src="./录制MP4视频/Leak_1_after.mp4" controls style="width: 100%; height: auto;"></video>

### (2) 注册和监听未正确释放导致的内存泄露

**准备工作**：

- 在 `BroadcastReceiverActivity` 的 `onCreate` 方法中，创建并注册了 `MyBroadcastReceiver` 实例，用于接收特定广播。

- 在 `onDestroy` 方法中，正确释放了注册的广播接收器 `myReceiver`，通过调用 `unregisterReceiver(myReceiver)` 来避免内存泄漏。



![image-20240715204824068](https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240715204824068.png)

**录制视频**：

**内存泄漏**：

[./录制MP4视频/Leak_2_before.mp4](./录制MP4视频/Leak_2_before.mp4)

<video src="./录制MP4视频/Leak_2_before.mp4" controls style="width: 100%; height: auto;"></video>

**修复之后**：

![image-20240715205056029](https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240715205056029.png)

## 2、分别在Activity的`onCreate`，Service的`onStartCommand`，`BroadcastReceiver`的`onReceive`方法中引发ANR，并通过`ANR-WatchDog`检查Log打印引发ANR大致的时间

### 准备工作：

1. 在项目的 `build.gradle` 中添加 `ANR-WatchDog` 依赖。
2. 在自定义的 `Application` 类中初始化并启动 `ANR-WatchDog`，设置 ANR 监听器以记录 ANR 日志。
   - ![image-20240715210309798](https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240715210309798.png)
3. 创建一个名为 `MyActivity` 的 Activity，在 `onCreate` 方法点击按钮， 点击事件中通过 `Thread.sleep(10000)` 模拟长时间阻塞以引发 ANR。
4. 创建一个名为 `MyService` 的 Service，在 `onStartCommand` 方法中通过 `Thread.sleep(10000)` 模拟长时间阻塞以引发 ANR。
5. 创建一个名为 `MyBroadcastReceiver` 的 `BroadcastReceiver`，在 `onReceive` 方法中通过 `Thread.sleep(10000)` 模拟长时间阻塞以引发 ANR。
6. 在 `AndroidManifest.xml` 中注册 `MyService` 和 `MyBroadcastReceiver`。
7. 在 `MyActivity` 中添加按钮以启动 `MyService` 和发送广播，触发相应的 ANR。
8. 运行应用并通过 Logcat 查看 `ANR-WatchDog` 打印的 ANR 日志，以确定引发 ANR 的时间和堆栈信息。

### **录制视频**：

#### `MyActivity`

[./录制MP4视频/MyActivity.mp4](./录制MP4视频/MyActivity.mp4)

<video src="./录制MP4视频/MyActivity.mp4" controls style="width: 100%; height: auto;"></video>

**通过log查看发生时间**：

![image-20240715210838887](https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240715210838887.png)

**系统的ANR信息**：

![image-20240716172930806](https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240716172930806.png)

#### `MyService`

[./录制MP4视频/MyService.mp4](./录制MP4视频/MyService.mp4)

<video src="./录制MP4视频/MyService.mp4" controls style="width: 100%; height: auto;"></video>

**通过log查看发生时间**：

![image-20240715213318098](https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240715213318098.png)


#### `MyBroadcastReceiver`

[./录制MP4视频/MyBroadcastReceiver.mp4](./录制MP4视频/MyBroadcastReceiver.mp4)

<video src="./录制MP4视频/MyBroadcastReceiver.mp4" controls style="width: 100%; height: auto;"></video>

**通过log查看发生时间**：

![image-20240715213037946](https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240715213037946.png)


## 3、优化`ANR-WatchDog`检测ANR机制 

**思路**：可以考虑针对发送到主线程的消息做个策略，将原来的5s发送一次改为1s发送一次，假如累计有5次发送且5次都得不到包，则表示有ANR的现象，再采集线程信息

### 准备工作：

**缩短检测间隔**：将检测间隔从5秒改为1秒。

**设置无响应阈值**：如果连续5次发送检测信号未响应，则认为发生ANR。

**定义变量**：

- `Handler`：用于在主线程执行任务。
- `Runnable`：用于定期检查主线程响应。
- `responseReceived`：标识是否收到响应。
- `notRespondingCount`：无响应计数器。
- `THRESHOLD`：无响应阈值5次。

**实现Runnable逻辑**：

- `checkResponseRunnable`：每秒检查一次响应状态，未响应计数达到阈值时记录线程信息。
- `checkRunnable`：每秒提交`checkResponseRunnable`给主线程。

**启动监控**：调用`start`方法，开始定期执行检测。

**收集和打印信息**：

- `collectThreadInfo`：收集并打印所有线程的堆栈信息。
- `printProcessInfo`：打印当前进程信息。

**应用程序中使用**：

- 在`MyANRWatchDogActivity`中启动`ANR WatchDog`。
- 故意引发ANR：延迟两秒后阻塞主线程10秒, 之后修改为8秒。

### **录制视频**：

[./录制MP4视频/MyANRWatchDog_1.mp4](./录制MP4视频/MyANRWatchDog_1.mp4)

<video src="./录制MP4视频/MyANRWatchDog_1.mp4" controls style="width: 100%; height: auto;"></video>

**阻塞时间改为8秒后**：

[./录制MP4视频/MyANRWatchDog_2.mp4](./录制MP4视频/MyANRWatchDog_2.mp4)

<video src="./录制MP4视频/MyANRWatchDog_2.mp4" controls style="width: 100%; height: auto;"></video>

