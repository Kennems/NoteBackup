# 青训营前端笔记

毅力，执行力，记忆力

回顾过去，最有创造力的时间都是在ddl来临之时，如果能时刻都能保持这份创造力，那么离成功就不远了。

谈出来的面试，有用的价值交换。

##### 自驱力

##### 好奇心

##### 学习能力

落地可衡量标准

##### 沟通表达能力

STAR原则 ： Situation（情景）Task（任务）Action（行动）Result（结果）

##### 技术规划能力



## 计算机网络

### 网络组成部分

- 主机：**客户端**和**服务端**
- 路由器
- 网络协议

小结：

- 网络组成部分：有主机、路由器、交换机等组成
- 网络结构：网络的网络
- 信心交换方式 ： 电路交换和分组交换
- 网络分层：各层职责，物理层、链路层、网络层、运输层和应用层
- 网络协议：标头和载荷

### Web应用

#### HTTP

##### HTTP1 

有队头堵塞（Head of Line Blocking)，无法多路复用的问题。

##### HTTP2

用帧的形式传输数据，带来以下好处：

- 调整响应传输的优先级
- 头部压缩
- Server Push

还是会有队头堵塞的问题。

##### HTTP 3：QUIC

- Quick UDP Internet Connection
- 现存网络设备对TCP和UDP支持已经僵化
- UDP不靠谱但是QUIC靠谱
- QUIC可以为除HTTP协议以外的应用层协议提供支持

#### CDN：DNS劫持

- 域名解析一般由网站自己处理
- 要加速的域名则重定向到CDN厂商的域名解析服务处理
- CDN厂商根据来源最近的CDN服务器的IP
- 用户直接访问最近的CDN服务器

#### WebSocket

- 有状态的持久连接
- 服务端可以主动推送消息
- 用WebSocket发送消息延迟比HTTP低

### 网络安全：如何实现身份验证

- 签名：用于鉴别身份和防止伪造
- 非对称加密性质：加密、解密使用不同的密钥（公钥和私钥），而且公钥加密只能用私钥解密、私钥解密只能用公钥解密。
- 数字签名：对明文内容的哈希值使用私钥加密，验证者使用公钥验证

HTTPS：

把HTTP的明文换成密文，再验证身份，即HTTPS。

HTTPS = HTTP + TLS

TLS = 身份验证 + 加解密

身份验证靠PKI

服务端身份验证靠PKI，客户端身份验证靠HTTP协议。

小结：

- 网络安全三要素：**机密性**、**完整性**和**身份验证**
- 在**没有提前交换秘密信息的前提下**，无法在不安全的信道交换秘密信息
- PKI保证了普通用户不需要“面对面”和根证书机构交换根证书
- HTTP使用PKI完成了出客户端身份验证以外的特性，客户端身份验证靠HTTP协议实现

## Linux基础

- Linux是现代化**应用程序交付**的首选平台，无论是部署在裸机、虚拟化还是**容器化环境**。
- 公司内部服务（TCE，FaaS，SCM)统一使用Debian Linux系统
- 熟悉Linux基础指令，熟练运维前端常用服务（Nginx,Node.js)
- 加深对操作系统概念和实现的理解，夯实基础知识

#### 查看Linux系统内核版本

```bash
uname -a
cat /proc/version
cat etc/os-release #查看发行版本
```

#### 四个部分

- 内核
- shell （命令解释器）
- 文件系统
- 应用程序

#### Linux体系结构

- 内核是硬件和软件之间的**中间层**
- 内核是一个**资源管理程序**
- 内核提供一组面向系统的**命令**

![](https://cdn.jsdelivr.net/gh/kennems/blog-image/20230505210210.png)

### 进程管理（树形结构）

- 进程是正在执行的一个**程序或命令**
- 进程有自己的地址空间，占用一定的**系统资源**
- 一个CPU核**同一时间只能运行一个进程**
- 进程由它的**进程ID（PID）**和它**父进程的进程ID（PPID）**唯一标识

#### 查看进程信息

```bash 
#查看启动的nginx进程
ps -ef | grep nginx
#查看某个进程
top -p 93824
#关闭指定的进程
kill 93824
#全部进程动态实时视图
top
```

#### 进程调度

进程调度是指操作系统按照某种策略或规则选择进程占用CPU进行运行的过程。

![](https://cdn.jsdelivr.net/gh/kennems/blog-image/20230505220239.png)

进程调度原则：

- 一个CPU核同一时间只能运行一个进程
- 每个进程有近乎相等的执行时间
- 对于逻辑CPU而言进程调度使用**轮询的方式执行**，当轮询完成则回到第一个进程反复
- 进程执行消耗时间和进程量成**正比**

内核空间（Kernal Space）：系统内核运行的空间

用户空间（User Space）：应用程序运行的空间

### 文件系统

文件系统是操作系统中负责**管理持久数据**的子系统，负责把用户的文件存到磁盘硬件中，持久化的保存文件。

Linux文件系统时采用树状的目录结构，最上层是/（根）目录

#### 虚拟文件系统

- 对**应用层**提供一个标准的**文件操作接口**
- 对**文件系统**提供一个标准的**文件介入接口**

```bash 
#df命令报告文件系统磁盘空间利用率
df -T
#mount命令是挂载文件系统用的，不带任何参数运行，会打印包含文件系统类型在内的磁盘分区的信息
mount
```

#### 文件读取流程

![](https://cdn.jsdelivr.net/gh/kennems/blog-image/20230505222724.png)

```bash
#查看当前登录用户信息
w
#查看当前用户所属的组
groups
#查看用户的uid信息
id xxxx
```

文件权限关于用户有三个概念：

所有者：文件的所有者

所在组：文件的所有者所在的组

其他人：除文件所有者所在组外的其他人

### Linux软件包管理

- 软件包
  - 通常只的是一个应用程序，可以是一个GUI应用程序、命令行工具或（其他软件程序需要的）软件库
- 软件包管理
  - 底层工具：主要用来处理安装和删除软件包文件等任务，DPKG，RPM
  - 上层工具：主要用于数据的搜索任务和依赖解析任务，APT，YUM，DNF

### 总结

今天学习了计算机网络和Linux基础，学习了日常网页传输的原理和安全传输的条件，了解了日常服务器的环境和开发实用环境——Linux，为日后开发打下基础。

## Shell脚本和编程

### Shell基础概念

#### 终端  tty 终端模拟器 Shell Bash

**终端**是获取用户输入、展示运算结果的硬件设备。

而**tty**是**teletypeWriter**的简称、和终端等价，早期之电传印机，在linux中是**输入/输出环境**。

**终端模拟器**是 Mac Terminal、iTerm2等，关联虚拟tty的输入输出软件。

**shell** 是command interpreter，处理来自终端模拟器的输入，解释执行之后输出结果给终端。

Bash 是shell的一种具体实现。

![](https://cdn.jsdelivr.net/gh/kennems/blog-image/20230506223031.png)

### Shell 语法和命令

#### 变量类型

![](https://cdn.jsdelivr.net/gh/kennems/blog-image/20230506223115.png)

#### 自定义变量

![](https://cdn.jsdelivr.net/gh/kennems/blog-image/20230506223311.png)

#### 系统环境变量

![](https://cdn.jsdelivr.net/gh/kennems/blog-image/20230506223458.png)

**注：**如果修改了系统配置，不会立即生效，需要我们重启终端或者执行source命令。

#### 配置文件加载

![](https://cdn.jsdelivr.net/gh/kennems/blog-image/20230506224044.png)

#### 运算符和引用

![](https://cdn.jsdelivr.net/gh/kennems/blog-image/20230506224134.png)

#### 管道

管道和管道符 **|** ， 作用是将前一个命令的结果传递给后面的命令。

```bash
cmd1 | cmd2
```

管道右侧的命令必须能接受标准输入才行，比如grep命令，ls,mv等不能直接使用，可以使用xargs预处理。

#### 重定向

##### 输出重定向符号

```bash
> : 覆盖写入文件
>> : 追加写入文件
2> : 错误输出写入文件
&> : 正确和错误输出同一写入到文件中
```

##### 输入重定向符号

```bash 
< 
<<
```

#### 判断命令

Shell中提供了test、[、[[ 三种判断符号，可用于

- 整数测试
- 字符串测试
- 文件测试

**语法：**

```bash 
test condition 
[ condition ]
[[ condition ]]
```

#### 分支语句

**语法1**

```bash
if condition ; then 
 程序段
elif condition ; then 
 程序段
else 
 程序段
fi
```

**语法2**

```bash 
case $变量 in:
	"第一个变量内容")
	程序段
	;;
	"第一个变量内容")
	程序段
	;;
	*)
	程序段
	;;
esac
```

#### 循环

```bash
while condition ; do 程序段 ; done 
until condition ; do 程序段 ; done
for var in [words...]; do 程序段; done
```

#### 函数

```bash
funcName(){echo "abc";}
function funcName() {echo "abc";}
```

#### 模块化

```bash
source [函数库的路径]
```

#### 常用命令

![](https://cdn.jsdelivr.net/gh/kennems/blog-image/20230506230654.png)

### 执行

在第一行指定**命令解释器**

启动方式

```bash
./filename.sh
bash ./filename.sh
source ./filename.sh
```

**执行过程**

**1、字符解析**

- 识别换行符、分号（；），做行的分割
- 识别命令连接符（|| && 管道）做命令的分割
- 识别空格、tap符号，做命令和参数的分割

2、shell展开

3、重定向

4、执行命令

- **builtin**直接执行
- 非**builtin**使用$PATH查找，然后启动子进程执行

5、收集状态并返回

#### Shell展开

大括号展开

```
(brace Expansion) {...}
```

波浪号展开

参数展开

```
(Shell Parameter Expansion) ${}
```

#### 命令替换（Command Substitution）

在子进程中执行命令，并用得到的结果替换包裹的内容，形式有两种： $(...) 或 ‘...'

文件名展开

### 课程总结

![](https://cdn.jsdelivr.net/gh/kennems/blog-image/20230506232141.png)

今天学习了Shell脚本编程，需要记忆的东西很多，下去要多多记忆练习，为后面学习打下好基础才是真正的学会。

## 编程范式

#### JavaScript

- 基于原型和头等函数的多范式语言
  - 过程式
  - 面向对象
  - 函数式
  - 响应式*

![](https://cdn.jsdelivr.net/gh/kennems/blog-image/20230507221608.png)

### 编程范式

**程序语言**具体**特性**

- 是否允许副作用
- 操作的执行顺序
- 代码组织
- 状态管理
- 语法和词法

**编程范式**

- **命令**式
  - 面向过程
  - 面向对象
- **声明**式
  - 函数式
  - 响应式

过程式编程

- 自顶向下

**程序**可细分为模块，模块又可细分为**变量**和**函数**。变量用具体**数据结构**来存储，而函数细化为**函数**和**语句**。

- 结构化编程

即**顺序**结构，**选择**结构，以及**循环**结构。

**缺点**：

- 数据与算法**关联弱**
- 不利于**修改**和**扩充**
- 不利于**代码重用**

### 面向对象编程

- 封装
  - 关联数据和算法
- 继承
  - 无需重写的情况下进行功能扩充
- 多态 
  - 不同的结构可以进行接口共享、进而达到函数复用
- 依赖注入*
  - 去除代码耦合

#### 	五大原则

- **单一职责**原则SRP(Single Responsibility Principle)
- 开放封闭原则OCP(Open－Close Principle)
- 里式替换原则LSP(the Liskov Substitution Principle LSP)
- 依赖倒置原则DIP(the Dependency Inversion Principle DIP)
- 接口分离原则ISP(the Interface Segregation Principle ISP)

#### 同样也有缺点：

编程过程类似打补丁，并且仅需简单功能也需要移植整个类。

### 函数式编程

#### Fitst Class Function

聚合转发

#### Pure Function 

- 优势
  - 可缓存
  - 可移植
  - 可推测
  - 可推理
  - 可并行

#### Currying 

#### Composition 

#### Functor

可以当作容器的类型，类型支持对容器内元素进行操作，常见的functor : Array(Iterable).map, Promise.then

#### Monad

可以去除嵌套容器的容器类型，常见 monad : **Array.flatMap** **Promise.then** 

#### Applicative

直接对两个容器操作

### 响应式编程

- 异步/离散的函数式编程
  - 数据流
  - 操作符
    - 过滤
    - 合并
    - 转化
    - 高阶

#### Observable

- 观察者模式
- 迭代器模式
- Promise / EventTarget 超集

#### 操作符

响应式编程的“compose"

- 合并
- 过滤
- 转化
- 异常处理
- 多播

![](https://cdn.jsdelivr.net/gh/kennems/blog-image/20230507225531.png)

### 领域特定语言

- Domain-specific language (DSL) : 应用于特定淋浴的语言

  - HTML

  - SQL

#### 语言运行过程

![](https://cdn.jsdelivr.net/gh/kennems/blog-image/20230507225858.png)

#### lexer

- SQL Token分类
  - 注释
  - 关键字
  - 操作符
  - 空格
  - 字符串
  - 变量

**推导式**：表示非终结符到（非终结符或终结符）的关系。**终结符**：构成句子的实际内容。可以简单理解为词法分析中的token。

**非终结符**：符号或变量的有限集合。它们表示在句子中不同类型的短语或子句。

#### Parser_LL & LR

**LL**：从左到右检查，从左到右构建语法树

**LR**：从左到右检查，从右到左构建语法树

### 总结

![](https://cdn.jsdelivr.net/gh/kennems/blog-image/20230507230253.png)

今天学习了编程范式中的基本问题，内容较多，为日常编程中的低层原理以及编程规范和编程方法，对理解深层编程语法有很大帮助，需要多多记忆。

## 客户端容器

Web浏览器以及跨端方案

### 浏览器架构

1. 单进程架构
   - 所有模块运行在同一个进程里，包含网络、插件、JavaScript运行环境等。
2. 多进程架构
   - 主进程、网络进程、GPU进程、插件进程
3. **面向服务架构**
   - 将原来的UI、数据库、文件、设备、网络等，作为一个独立的基础服务。

### 渲染进程

#### 多线程架构

内部是多线程实现，主要负责页面渲染，脚本执行，事务处理，网络请求。

线程

- JS引擎
- GUI渲染
- 定时器触发
- 网络线程
- 事务触发

#### 多进程工作流程

1. 网络线程负责加载网页资源
2. JS引擎解析JS脚本并且执行
3. JS解析引擎空闲时，渲染线程立即工作
4. 用户交互、定时器操作等产生回调函数放入任务队列中
5. 事务线程进行事务循环、将队列里的任务取出交给JS引擎执行

### Chrome运行原理

#### 如何展示网页

- 浏览器地址输入URL后发生了什么

![](https://cdn.jsdelivr.net/gh/kennems/blog-image/20230508231252.png)

1. 先确定式URL内容还是query查询
2. 开始导航
3. 读取响应，确定响应主体为HTML还是其他类型文件
4. 寻找渲染进程
5. 资源加载
6. 构建渲染树
7. 页面布局 
8. 页面绘制（图层结构）

### 前端性能

#### 首屏优化

1．压缩、分包、删除无用代码

2．静态资源分离

3．JS脚本非阻塞加载

4．缓存策略

5．SSR

6．预置loading、骨架屏

#### 渲染优化

1． GPU加速

2．减少回流、重绘

3．离屏渲染

4．懒加载

#### JS优化

1．防止内存泄漏

2．循环尽早break

3．合理使用闭包

4．减少Dom访问

5．防抖、节流

6．Web Workers

### 跨端容器

#### 为什么需要跨端

1．开发成本、效率

2．一致性体验

3．前端开发生态

#### 有哪些跨端方案

- webview

- 小程序

- RN/WeeX

- Lynx

- Flutter

### 跨端容器-WebView

1．WebvieW，即网页视图,用于加载网页Url，并展
示其内容的控件
2.可以内嵌在移动端App内，实现前端混合开发，大
多数混合框架都是基干Webview的二次开发；比如
lonic、Cordova

#### 跨端容器-使用WebView优势

1．一次开发，处处使用,学习成本低
2．随时发布，即时更新，不用下载安装包
3．移动设备性能不断提升，性能有保障
4．通过JSBridge和原生系统交互，实现复杂功能

#### 跨端容器-WebView使用原生能力

##### Javascript 调用Native

- APl注入：Native获取Javascript环境上下文，对其挂载的对象或者方法进行拦截

- 使用Webview URL Scheme 跳转拦截

- IOs上window.webkit.messageHandler直接通信

##### Native 调用 Javascript

- 直接通过webview 暴露的 API 执行JS代码

- IOS webview.stringByEvaluatingJavaScriptFromString

- Android webview.evaluateJavascript

#### 通信跨端容器-WebView<->Native

1. JS环境中提供通信的 JSBridge
2. Native 端提供 SDK 响应 JSBridqe 发出的调用

3. 前端和客户端分别实现对应功能模块

#### 跨端容器-小程序

1．微信、支付宝、百度小程序、小米直达号
2．染层-webview
3．双线程，多webview架构
4．数据通信，Native转发

### 总结

![](https://cdn.jsdelivr.net/gh/kennems/blog-image/20230508234023.png)

今天主要介绍了客户端容器的相关知识，包括浏览器架构、渲染进程、Chrome运行原理以及前端性能等方面。在跨端容器方面，介绍了WebView和小程序的使用及优劣。其中，WebView作为一种混合开发的解决方案，可以通过JSBridge和原生系统交互，实现复杂功能；而小程序则采用染层-webview的架构，实现数据通信转发。总的来说，了解客户端容器的相关知识对于前端开发人员具有很大的帮助，可以提高开发效率和用户体验。

## 0421理解CSS

CSS（**C**ascading **S**tyle **S**heet）对HTML做补充，做效果。现在使用的为最新的CSS3.

### 层叠（Cascading）

层叠三大规则：（优先级依次递减）

1. 样式表来源
2. 选择器优先级
3. 源码位置

1、样式表来源**重要次序排序**

1. 用户代理样式（浏览器默认样式）
2. 用户样式表 很少有
3. 作者样式表 developer写的
4. 作者样式表中的 **！important**
5. 用户样式表中的  **！important** 
6. 用户代理样式表中的 **！important**

2、**选择器**优先级

具体优先级：

![](https://cdn.jsdelivr.net/gh/kennems/blog-image/20230509211752.png)

**源码顺序**：

The **last declaration** in document order **wins**.

1. 对于@import的样式，根据@import的顺序
2. 对于link和style标签的样式，根据在document中的顺序决定。

- 选择器尽量少用id
- 尽量不要用！important
- 自己的样式加载在引用库样式的后面

#### 继承

继承方向：

![](https://cdn.jsdelivr.net/gh/kennems/blog-image/20230509212345.png)

- 大部分具有继承特性的属性和**文本相关**，color、font、font-family、font-size、font-weight、font-variant、fontstyle、line-height、letter-spacing、text-align、text-indent、texttransform、white-space以及word-spacing。还有少部分列表、表格的属性。

- 可以使用inherit关键字显式指定一个属性值从其父元素继承

#### CSS值和单位

- 单位
  - 长度
    - 绝对长度：px,pt,cm,in...
    - 相对长度：em,rem,ex,rex,...vw,vh,vmin,vmax
  - 角度 ： deg,grad,turn,rad
  - 时间 : s,ms
  - 分辨率 : dpi,dpcm,dppx
- 值
  - 文字类：比如像initial这种关键字，颜色、位置等等
  - 数值类：比如z-index:1这种数值，或者带有单位的数值、百分比等
  - 函数生成：比如calc()，min()，max()等

#### 盒模型

浏览器根据**视觉格式化模型**(visual formatting model),将所有元素表示为盒子模型，css通过盒模型做layout。

- 控制盒子类型display: block、inline、inline-block、flex、…

- 控制盒子大小&计算方式width，height …box-sizing: content-box、border-box

- 控制盒中内容流overflow: auto、scroll、hidden、…

- 控制定位position: static、relative、absolute、fixed、sticky
- 是否可见visibility: visible、hidden、…

padding、border、margin中，只有margin可以设置**负值**

#### 常规流布局

任意的盒子display

- **外部显示类型**（display-outside):规定了该盒子如何与同一格式上下文中的其他元素**一起显示**。
- **内部显示类型**（display-inside):规定了该盒子内部的布局方式。比如display: flex;其外部显示是block，参与**BFC**；display: inline-flex，则外部显示是inline，参与IFC。他们内部的盒子都参与弹性盒子布局。

常规流的盒子

- 外部显示为**block**
  - display: block | flex | grid |table | flow-root |…
  - **块级格式化上下文（BFC）**（block formatting context）
- 内部显示为**inline**
  - display: inline | inline-block |inline-flex | inline-grid |inline-able | …
  - 参与内联级**格式化上下文**（inline formatting context）

#### 弹性盒子布局

Flexible Box Layout是为了提供更加高效灵活的布局方式，在即便是宽高未知的情况下，也能排列和分割一个盒子内部的布局。而且在不同布局方向（横向/纵向）的调整更为灵活。

#### 网格布局

2017年推出的Grid布局可以定义由行和列组成的二维布局，然后将元素放置到网格中。元素可以只占其中一个单元格，也可以占据多行或多列。

##### Flex 和 Grid

建议：

1. 大面积或整体布局推荐使用Grid布局
2. 小面积或组件中，或Grid Item中可以使用Flex做灵活布局

#### 定位Position

为了我们可以在文档流的基础上，让元素移动，做出更多灵活的改变。当position属性的取值非static的时候，可以使用top, right, bottom, left对其**进行定位**。

### 层叠上下文 (The Stacking Context)

层叠上下文是对HTML元素的三维构想，将元素沿着垂直屏幕的虚构的Z轴排开。

**形成新的层叠上下文**的条件（任一即可）：

- position: relative或absolute;并且z-index不是auto

- position: fixed或sticky

- flex或grid的子元素；并且z-index不是auto

- opacity的值小于1

- transform的值不为none

- will-change的值不为通用值

- ……详见规范

#### 层叠顺序

层叠级：

![](https://cdn.jsdelivr.net/gh/kennems/blog-image/20230509220233.png)

关于**z-index**的使用建议：

1. 使用css变量或者预处理语言的变量，管理z-index的值
2. 将预设间隔设置10或100，方便后续的插入

#### 变形、过度、动画

transform变形

**2D**相关属性：

- transform: translate(移动)、rotate(旋转)、scale(放缩)、matrix(变形矩阵)等
- transform-origin: right top、center等表示变形时依据的原点

**3D**相关属性：

- transform: translate3d、rotate3d、scale3d、matrix3d等

- transform-origin: right top、50px 30px等表示变形时依据的原点

- transform-style: flat或preserve-3d看子元素的3d表现perspective：观看点距离z=0这个平面的距离,可以在transform中用

- perspective()使用作用为当前元素，也可以直接使用，给后代元素一个统一值

- perspective-origin：观看者的位置，如top、bottom等

- backface-visibility：元素正面只有朝向观察者的时候可见

#### Transition 过渡

通过指定某些元素属性从一种起始状态，在一段时间内以某种变化节奏，过渡到终止状态。

#### Animation 动画

- @keyframes关键帧用来定义动画过程中出现的关键样式
- animation-*相关属性用来为元素添加动画

#### transform transition animation 性能

如何写动画性能更好？

1.尽量不用触发reflow的属性

2.在遇到性能问题时可以触发硬件加速，比如设置will-change属性、设置transform3d等

3.尽量使用transform和opacity去写动画

### 响应式设计

#### 媒体查询

媒体查询允许某些样式只在页面满足特定条件时才生效。我们可以将媒体类型（如screen、print）以及媒体特性（如视口宽度、屏幕比例、设备方向：横向或纵向）做为约束条件。

使用媒体查询的一些Tips

1.媒体查询同样遵循cascading层叠覆盖原则，min-和max-选择一个

2.由于设备的多样化逐渐不可枚举，断点的选择尽量根据内容选择

3.由于断点的增加会增加样式处理的复杂度，所以尽量减少断点

#### 设备像素

$$
假设像素是X*Y \\
PPI=X/屏幕宽度(inch)=Y/屏幕宽度(inch)=\sqrt(X^2+Y^2)/屏幕宽度(inch)
$$

$$
DPR(设备像素比)=设备像素/CSS像素
$$

#### viewport

常见的移动端viewport的设置

1.保持scale为1

2.保持scale放缩参数是1/dpr

#### 相对长度的使用

##### em

- 在非font-size属性中使用是相对于自身的字体大小
- 在font-size上使用是相对于父元素的字体大小(**一般不在这个属性上使用**，因为font-size的继承特性，多重嵌套后大小会不断放大或缩小，产生混乱)

##### rem

根元素的字体大小。通过伪类:root或者html选择器选定。由于是根元素的font-size，所以不会像em那样出现多重嵌套问题，减少了复杂性，同时作为一个相对单位，可以进行适配放缩，可以用来做响应式布局.

##### vw & vh

vw：视窗宽度的1%。vh：视窗高度的1%。同样，vw也可以作为响应式布局的基准单位。由于vw天然是视口宽度的1%，所以不需要js动态配置。应用和rem方案类似.

### CSS生态相关

### 总结

本次课程主要讲解了CSS（Cascading Style Sheet）的相关知识。首先介绍了CSS层叠及规则，其中包括样式表来源、选择器优先级和源码位置等重要规则。接着，讲解了CSS的盒模型、常规流布局、弹性盒子布局和网格布局等相关概念。并深入探讨了CSS的定位属性、层叠上下文和相应的层叠顺序等，以及变形、过渡和动画等特性。最后还详细讲解了响应式设计中的媒体查询、设备像素、viewport、相对长度的使用等相关知识。

总之，CSS作为前端开发中不可或缺的重要组成部分，是实现Web页面美化以及响应式布局的核心技术。同时，也需要注意其层叠、继承等规则，尽量避免影响其性能。

# 前端语言的基本能力

如果将网页比作人的身体，那么HTML就是骨骼，CSS则是皮肤，而JavaScript就是肌肉。这三种语言在前端开发中十分重要。

### HTML

HTML即超文本标记语言，是构成网页内容的最基础语言。它可以将图片、文字、视频、音频、程序等元素引入到网页中，是网页骨架的基础。

### CSS

CSS是层叠样式表，通过为标签添加样式属性进行布局规范，以实现页面的美化和排版，是网页皮肤的关键。

### JavaScript

JavaScript是一种具有函数优先、动态脚本语言特点的编程语言。它在Web开发中非常常用，主要用于为网页添加交互功能。它支持面向对象、命令式、声明式、函数式编程范式，是网页肌肉的核心。

## 前端语言的协作配合

HTML、CSS和JavaScript是相互支持、相互制约的三种语言。在开发中，它们共同构建了从简单的网站结构到高级的交互功能的整个过程。

例如，在网页开发中，HTML负责创建和构建网站的内容，CSS为这些结构添加样式和格式，JavaScript将这些结构变成用户可以与之交互的界面。在开发中，三种语言的协作配合非常重要。

## 你不知道的HTML5

HTML5是HTML的第五个版本，相对于以往版本，它引入了一些新的技术和特性，例如ARIA、表单增强、存储、IndexedDB、Shadow DOm、Web Component、PWA和AMP等。这些技术和特性为Web开发带来了更多便利和可能性，在后续的学习和实践中值得深入研究。

- ARIA（Accessible Rich Internet Applications）是一套规范，用于增强Web应用和网站的可访问性。
- HTML5表单增强引入了新的表单元素，如date、time、email、url等，使得开发者可以更容易地创建各种类型的表单。
- HTML5存储包括IndexedDB等，用于在浏览器中存储大量的结构化数据。
- Shadow DOM用于避免内部元素被外部元素访问。
- Web Component则是一种新的组件化开发方式，使得Web应用可以更加模块化和可复用。
- PWA是一种Web应用程序的开发方式，旨在提供类似于原生应用程序的用户体验。
- AMP则是一种Web页面的开发方式，旨在提供快速的加载速度和优化的移动体验。

![](https://cdn.jsdelivr.net/gh/kennems/blog-image/20230509100618.png)

### head

![](https://cdn.jsdelivr.net/gh/kennems/blog-image/20230509100657.png)

![](https://cdn.jsdelivr.net/gh/kennems/blog-image/20230509100811.png)

### HTML5 

#### WebAssembly



## 总结

本文主要介绍了前端语言的基本能力，协作配合以及HTML5中一些不为人知的特性。在学习过程中，我们了解了HTML、CSS、JavaScript三种语言分别的作用和在开发中的配合方式，以及HTML5中的新技术和应用。熟悉这些内容，有助于我们更好地开发出高质量、高效率的Web应用。

# 第二天 深入理解JS

## JS基本概念

JavaScript在1995年被Brendan Eich开发。 

JS的基本概念

- 单线程
- 动态、弱类型
- 面向对象、函数式
- 解释类语言、JIT（Just-In-Time）
- 安全、性能差

数据类型

- 对象
  - 数组
  - 函数
- 基础类型
  - 字符串
  - 数字
  - 布尔 
  - undefined
  - null
  - symbol
  - bigInt

### 作用域

变量的可访问性和可见性

静态作用域：通过它就能够预测代码在执行过程中如何查找标识符。

- 全局作用域
- 函数作用域
- 块级作用域

### 变量提升

- var有变量提升
- let，const没有变量提升，提前访问会报错
- function函数可以先调用再定义
- 赋值给变量的函数无法提前调用

一段JavaScript代码-》编译阶段-》执行阶段

## JS是如何执行的

AST（Abstract Syntax Tree）抽象语法树

![JS执行过程](https://cdn.jsdelivr.net/gh/kennems/blog-image/20230504221653.png)

### 执行上下文

当JS引擎解析到可执行代码片段（通常是函数调用）的时候，就会先做一些执行前的准备工作，这个工作，就叫**执行上下文（execution context 简称EC）**，也叫执行环境。

- 全局执行上下文

  代码开始执行时就会创建，将他压执行栈的栈底，**每个生命周期内只有一份**

- 函数执行上下文

  当执行一个函数时，这个函数内的代码会被编译，生成变量环境、词法环境等，等**函数执行结束的时候**该执行环境从栈顶弹出。

- Eval执行上下文

执行上下文做了什么事？

- 绑定This
- 创建

## JS进阶知识点

### 闭包

本质是一个没有被回收的对象

### this

- 普通函数this指向Window
- 对象
  1. 对象调用指向对象
  2. 先赋值再调用，看调用的地方
- new操作
  1. 创建临时对象
  2. 将this指向临时对象
  3. 执行构造函数
  4. 返回临时对象

### 垃圾回收

堆的垃圾回收

**新生代空间：**

1. 垃圾标记
2. 对象复制
3. 区域反转

**老生代空间：**

新生代空间两轮还未被回收的对象加入老生代，垃圾回收机制同新生代垃圾回收机制。

### 事件循环

微任务队列和宏任务队列。**微任务队列先于宏任务队列。**

## 总结

![](https://cdn.jsdelivr.net/gh/kennems/blog-image/20230504230727.png)

图片内是课程中的**主要内容**，课程中主要讲解了JS区别于其他高级语言的特性，JS自身对于对象和函数的底层逻辑、垃圾回收的过程等，这些原理性知识对JS的执行过程和原理有很大帮助，帮助我快速理解JS特性。

# 深入浅出TypeScript

- TypeScript是JavaScript的超集，用于解决大型项目的代码复杂性。
- 强类型，支持静态和动态类型。
- 可以在编译期间发现并纠正错误。
- 不允许改变变量的数据类型。

## TS基础

### 基础类型

1. boolean、number、string
2. undefined、null
3. any、unknown、void
4. never
5. 数组类型[]
6. 元组类型tuple

### 函数类型

**定义**：TS定义函数类型是要定义输出参数类型和输出类型

输入参数：参数支持可选参数和默认参数

输出参数：输出可以自动推断，没有返回值时，默认为void类型

函数重载：名称相同但参数不同，可以通过重载支持多种类型

### interface

定义：接口是为了**定义对象类型**

特点

- 可选属性：？
- 只读属性：readonly
- 可以描述函数类型
- 可以描述自定义属性

总结：接口非常灵活duck typing（鸭子类型）

### 类

定义：写法和JS差不多，增加了一些定义。

特点：

- 增加了public,private,protected**修饰符**
- 抽象类
  - **只能被继承**，不能被实例化
  - 作为基类，抽象方法必须被**子类实现**
- interface约束类，使用implement关键字

### 高级类型

1、联合类型 | 

2、交叉类型 & 

3、类型断言

4、类型别名（type VS interface）

- 定义：给类型起个别名
- 相同点：
  1. 都可以定义对象或函数
  2. 都允许继承
- 差异点：
  1. interface是TS用来定义对象，type是用来定义别名方便使用；
  2. type可以定义基本类型，interface不行；
  3. interface可以合并重复声明，type不行；

### 泛型

- 基本定义：

1. 泛型的语法是<>里面写类型参数，一般用T表示；
2. 使用时有两种方法指定类型：
   1. 定义要使用的类型
   2. 通过TS类型推断，自动推导类型
3. 泛型的作用是临时占位，之后通过传来的类型进行推导；

### 基础操作符

- typeof : 获取类型
- keyof : 获取所有键
- in : 遍历枚举类型
- T[K] : 索引访问
- extends : 泛型约束

### 常用工作类型

- Partial<T>:将类型属性变为可选

- Required<T>:将类型属性变为必选

- Readonly<T>:将类型属性变为只读

- Pick、Record…

## 实战

### 声明文件

- declare:三方库需要类型声明文件

- .d.ts：声明文件定义
- @types：三方库TS类型包
- **tsconfig.json**：定义TS的配置



# 第三天 React基础与实践

React：用于构建用户界面的**JavaScript库**。

## React哲学（Thinking In React）

React是用JavaScript构建快速响应的大型Web应用程序的首选方式之一。

影响Web性能的两大主要原因：（快速响应的**瓶颈**）

**解决方法：**

1. 等待资源加载
   1. React.Lazy（动态加载）
   2. React.Suspense
   3. ErrorBoundary(资源加载失败提示)
2. 浏览器线程执行
   1. 异步更新
   2. 时间切片
   3. React Fiber

```javascript
import React, { useState, Suspense } from 'react';   // 引入React相关组件
import { Tabs } from 'antd';   // 引入Ant Design中的Tabs组件

// 定义组件
const MyTabs = ({ routes }) => {
  const [activeKey, setActiveKey] = useState('1');   // 用useState定义当前激活的Tab key

  // 组件渲染方法
  const renderTabs = () => {
    return routes.map((item) => {
      const Component = React.lazy(() => import(`./${item.key}`));   // 使用React.lazy动态加载Tab内容

      // 定义Tab内容渲染方法
      const RenderComponent = (
        <Suspense fallback={"资源加载中..."}>
          <Component />
        </Suspense>
      );
      
      // 返回一个TabPane组件
      return (
        <Tabs.TabPane key={item.key} title={item.name}>
          {RenderComponent}
        </Tabs.TabPane>
      );
    });
  };

  // 返回最终的Tabs组件
  return (
    <Tabs activeTab={activeKey} onChange={setActiveKey}>
      {renderTabs()}
    </Tabs>
  );
};

// 导出组件
export default MyTabs;

```

### 更新流程

- **Scheduler（调度器）**
  - 维护时间切片（类似requestldleCallback）
  - 与浏览器任务调度
  - 优先级调度

- **Reconciler（协调器）**
  - 将JSX（React中的特殊语法）转化为Fiber
  - Fiber树对比（双缓存）
  - 确定本次更新的Fiber

- **Renderer（渲染器）**
  - 渲染器用于管理一棵React树，使其根据底层平台进行不同的调用。

优缺点：

优点：

- 快速响应：Fiber
- 组件化：复用性强
- 声明式编程
- 跨平台：只需修改渲染器

缺点：

- 大型引用需要配套学习 状态管理、路由设备
- 不适合**小型应用**，需要用Babel处理

## React基础

### Web 应用

- 打包配置：JSX -> babel -> JS加载优化和错误降级。
- React Router向应用中快速地添加视图和数据流，保持页面与URL间的同步。
- 可复用UI -> 组件 -> 页面。可复用逻辑抽离成hook。
- 多页面多组件共享信息redux & context

### 组件

- 通过定义state操作视图Mount时获取数据更新stateRef保存与视图无直接关系的值unMount前清空Ref
- props父子组件通信context & redux组件信息共享
- 数据决定视图通过Ref获取到DOM
- 函数使用useCallback值或者计算使用useMemo组件包裹memo

函数式组件的优点：

- 代码量骤减，组件干净清爽
- 没有复杂的生命周期
- 支持自定义hook，逻辑复用方便

### Hook规则 & 原理

组件和Hook的关系

- 我们将UI拆成多个独立单元，这些单元组合可以构成多种视图展示，这些独立单元就是组件。组件相当于原子。
- hook贴近组件内部运行的各种概念逻辑，effect、state、context等。hooks更贴切于电子。

只能在 React 函数中调用Hook

- 在React函数组件中 或自定义Hook中调用

- 自定义Hook必须以use开头

- Hook中的state是完全隔离的

### Hook过期闭包问题

过期闭包指的是当一个变量在创建闭包时被捕获，并且该变量在后续的执行过程中发生了改变，而闭包中仍然保存着旧值的情况。

因为因为 Hook 可以在函数组件中捕获和更新组件状态，并且每次渲染时都会重新执行，确保状态的正确性。所以使用Hook解决过期闭包问题。

如程序：

```js
import React, { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);

  function handleClick() {
    setCount(count + 1);
  }

  return <button onClick={handleClick}>点击 {count} 次</button>;
}
```

由于 useState Hook 在每次渲染时都会重新执行，因此 count 变量和 setCount 函数的闭包是实时更新的，避免了过期闭包问题的出现。

## React常用API及其作用

### 类组件基类 `React.Component`

- `React.Component` 是 React 类组件的基类。
- 类组件继承 `React.Component` 后，可以通过实现 `render` 方法来返回要渲染的 React 元素。

### 浅层对比 `React.PureComponent`

- `React.PureComponent` 继承自 `React.Component`，并重写了 `shouldComponentUpdate()` 方法。
- `React.PureComponent` 内置了浅层对比（`shallow compare`） props 和 state 进行性能优化。
- 适用于组件仅依赖于 props 和 state 的情况。

### 高阶组件 `React.memo`

- `React.memo` 是一个高阶组件，用于只比较 `props` 变更的情况下避免不必要的渲染。
- 当前组件的 `props` 不变时，`React.memo` 可以使用上一次渲染结果缓存，从而提高性能。

### 创建 React 元素 `React.createElement`

- `React.createElement` 是创建并返回 React 元素的函数，可以用于在不使用 JSX 的情况下构建 React 应用。
- 函数的第一个参数是标签名或组件类型，第二个参数是 props，第三个参数及之后的参数是子元素。

### 克隆 React 元素 `React.cloneElement`

- `React.cloneElement` 是用于克隆并返回包含新 props 的 React 元素的函数。
- 可以通过这个函数为新元素添加额外 `props` 或者覆盖原有 `props`。

### 遍历操作 `React.Children`

- `React.Children.map` 用于遍历 React 子元素并返回一个新的子元素数组，可以在遍历过程中为子元素添加或修改 `props`。
- `React.Children.forEach` 用于遍历 React 子元素，不能返回新的子元素数组。
- `React.Children.count` 用于获取子元素数量。
- `React.Children.only` 用于判断是否只有一个子元素。

### 创建 ref `React.createRef`

- `React.createRef` 用于创建一个 ref，并附加到具体元素上，在 class 组件中可以使用该 ref 获取 dom 结构。

### 转发 ref `React.forwardRef`

- `React.forwardRef` 可以让组件转发 ref，使父组件可以获取子组件的 dom 元素或执行子组件的方法。
- 可与 `useImperativeHandle` 配合使用。

### 动态加载组件 `React.lazy`

- `React.lazy` 可以实现组件的动态加载和构建，提高应用性能。
- 只能在函数组件中使用，不支持 SSR 和服务端渲染。

### 优雅降级 `React.Suspense`

- `React.Suspense` 是一个组件，在资源未准备好时可以优雅地降级。
- 可以用于等待代码分割、组件懒加载、异步请求等场景。

## React常用Hooks及其使用

React Hooks 是 React 16.8 引入的一项功能，可以让**函数组件**拥有类似于 **class 组件**的功能。以下是 React Hooks 的常用函数：

### useState

- `useState` 返回一个数组 `[state, setState]`，其中 `state` 表示当前状态的值，`setState` 是一个函数，用于更新 `state` 的值。

### useEffect

- `useEffect` 用于在函数组件中执行副作用操作，比如网络请求、订阅事件等。
- 可以在挂载后、依赖变化时、组件卸载前等场景下执行操作。
- 接收两个参数：第一个参数是一个函数，表示要执行的操作；第二个参数是一个数组，用于指定影响该操作的变量，若该数组为空，则表示该操作仅在挂载和卸载时执行。

### useContext

- `useContext` 用于接收最近的上层 `context` 对象，并返回其值。
- 一般与 `createContext` 一起使用，可以让子组件获取到父组件传递下来的数据。

### useRef

- `useRef` 返回一个可变的 `ref` 对象，在组件生命周期内持续存在。
- 可以用于保存任意可变值，也可以和其他 DOM API 一起使用获取 DOM 元素或者保存一些组件内的状态。

### useMemo

- `useMemo` 接收两个参数：第一个参数是计算函数，第二个参数是依赖数组。
- 只有在依赖项变化时才调用计算函数，并返回计算值。
- 可以用于优化计算量较大的操作。

### useCallback

- `useCallback(fn, deps)` 相当于 `useMemo(() => fn, deps)`，一般返回的是一个新函数。
- 可以用于避免子组件不必要地重新渲染。

### useReducer

- `useReducer` 是 `useState` 的更丰富替代方案。
- 返回 `[state, dispatch]`，其中 `state` 可以是复杂对象，`dispatch` 可以更新这个复杂对象。

### useImperativeHandle

- `useImperativeHandle` 可以让组件向父组件暴露方法。
- 一般和 `forwardRef` 一起使用。

### useLayoutEffect

- `useLayoutEffect` 的执行时机是浏览器把内容真正渲染到界面之前，和 `componentDidMount` 等价。
- 和 `useEffect` 的执行时机不同，`useEffect` 的执行时机是在浏览器完成渲染之后。

## 具体场景案例

- 对一个网页划分组件

  - _Layout

  - _Page

  - _Component

- 组件间通信案例
- 组件间共享信息
- 组件性能优化

- 组件挂载位置
- 逻辑复用

# React 状态管理

## React状态管理简介

状态管理工具的本质：管理共享内存中的状态

1. 共享内存
2. 管理状态
3. 页面通信
4. 组件通信
5. 刷新失效？

**详细定义**：单页应用的各个组件本身是共享内存的，如果将状态保存在内存中，就可以读写同一内存中的变量，从而达到状态共享的目的。

React状态管理工具可以分为几下几类：

- React自带：Local State（props）和 Context

- 单向数据流:Flux、Redux(Redux-toolkit)
- 双向数据绑定:Mobx
- 原子型状态管理:Recoil、Jotai
- 异步操作密集型:Rxjs

每一种状态管理工具都有其不同的适用性，不同场景下需要合理的选择状态管理工具。

### 1、Local State(props)

local state是组件级别的局部状态。当组件创建时初始化生效，组件销毁时失效。

React的数据流是自上而下的，大部分情况下local state即可满足需求，但也有例外：比如组件之间无法共享状态。这样我们可以将状态向上一级，由父组件自上而下的传递。

但是延伸的层次过高之后，local state的方式就不太实用了。这时，子页面和子页面之间的通信，**React本身提供了Context**。

### 2、Context

![](https://cdn.jsdelivr.net/gh/kennems/blog-image/20230511204715.png)

**缺点：**OtherDisplay没有用到Context里的value，但是Context的值变换，otherDisplay也会重新渲染。
React中的Context解决了react中, props或者state进行多级数据传递,则数据需要自顶下流经过每一级组件，无法跨级的问题。但是Context在页面间共享数据的时候同样有很多问题;

1. Context相当于**全局变量**，难以追溯数据的变更情况
2. 使用Context的组件内部**耦合度太高**，不利于组件的复用和单元测试
3. 会产生不必要的更新(比如会穿透memo和dependicies等)
4. Context只能存储单一值，无法存储多个各自拥有消费者的值的集合。
5. 粒度也不太好控制,不能细粒度的区分组件依赖了哪一个Context
6. 多个Context会存在层层嵌套的问题

### 3、Redux

Redux的三大原则：**单一数据源**，**只有一个store**，store中的state是**只读**的，使用**纯函数**来执行修改的。

### 4、Mobx

它通过透明的函数响应式编程使得状态管理变得简单和可扩展,**Mobx**跟**Vue**的设计比较相似，是一个响应式的状态管理库。Mobx借助于装饰器的实现，使得代码更加简洁易懂。由于使用了可观察对象，所以Mobx可以做到直接修改状态，而不必像Redux一样编写繁琐的actions和reducers。

### 5、Recoil

解决的问题：

1. 组件间的状态共享只能通过将state 提升至它们的公共祖先来实现，但这样做可能导致重新渲染一颗巨大组件树。
2. Context 只能存储单一值，无法存储多个各自拥有消费者的值的集合。

Recoil更加具有原子性，比如在Recoil的状态都是Atom，可以进行**任意组合**等。

### 6、Zustand

Zustand是主打轻量级的状态管理工具，没有Redux那样臃肿的设计，也没有兼容React类组件的历史包袱， Zustand状态管理工具体积很小，因此很适合移动端的网页。

Zustand库的核心API和Redux极为相似，区别主要在**状态的更新**，Redux通过dispatch和reducer函数来进行装填更新，而Zustand则是可以通过setState来直接修改状态。

![](https://cdn.jsdelivr.net/gh/kennems/blog-image/20230511210615.png)

## 实现一个简易的状态管理工具

### 发布/订阅模式

![](https://cdn.jsdelivr.net/gh/kennems/blog-image/20230511211358.png)

```js
export default class CreateStore{
    constructor(reducer,initialState){
        // 初始化创建一个Store实例，需要传入reducer和initialState参数
        // reducer：用于管理应用程序的状态。接收一个旧的state和一个action，返回一个新的state
        // initialState：存放当前的state对象
        this.currentReducer = reducer;
        this.currentState = initialState;
        this.listeners = []; // 订阅者列表，用于存放监听store变化的回调函数
        this.isDispatching = false; // 当前是否在执行dispatch函数
    }
    
    getState(){
        // 获取当前的state对象
        return this.currentState;
    }
    
    subscribe(listener){
        // 添加一个订阅者，将回调函数加入订阅者列表中，并返回一个取消订阅的函数
        this.listeners.push(listener);
        return function unsubscribe(){
            var index = this.listeners.indexOf(listener);
            this.listeners.splice(index,1);
        };
    }
    
    dispatch(action){
        try{
            this.isDispatching = true; // 将isDispatching标志设置为true，表示当前正在执行dispatch函数
            this.currentState = this.currentReducer(this.currentState, action); // 执行reducer函数，生成新的state对象
        }finally{
            this.isDispatching = false; // 执行完毕，将isDispatching标志设置为false
        }
        
        // 遍历订阅者列表，执行所有监听回调函数
        this.listeners.slice().forEach(function(listener){
            listener();
        });
        
        // 返回当前的 action，方便调试
        return action;
    }
}
```

## Redux在项目中的实践

确定为什么要实用Redux：redux作为一款状态管理工具，主要是为了解决组件间通信的问题。

减少局部状态和redux状态的不合理混用。



# React路由与项目实践

路由（Router）：路由（Router）是一种负责寻径的网络设备，它在互连网络中从多条路径中寻找通讯量最少的一条网络路径提供给用户通信。路由用于连接多个逻辑上分开的网络。对用户提供最佳的通信路径。

**网页发展历程：**

![](https://cdn.jsdelivr.net/gh/kennems/blog-image/20230512192232.png)

即：路由是**桥梁**，帮助需求方找到供给方，并进行交换。

## 路由项目实践

在 React 中使用路由可以通过第三方库 React Router 来实现。React Router 提供了一个路由器（`Router`）和多个不同类型的路由组件，可以方便地实现页面之间的跳转和管理。常用的路由组件有 `Route`、`Link` 和 `Switch` 等。其中，`Route` 用于定义具体的路由规则和对应的组件，`Link` 用于生成链接到指定路由的超链接，而 `Switch` 则用于在多个路由规则之间进行匹配，并渲染与当前 URL 匹配的第一个组件。

React Router 使用基本步骤如下：

1. 安装 React Router：

   ```js
   bashCopy Codenpm install react-router-dom --save
   ```

2. 引入需要的路由组件：

   ```js
   javascriptCopy Codeimport { BrowserRouter as Router, Route, Link, Switch } from 'react-router-dom';
   ```

3. 在应用程序中添加 `Router` 组件：

   ```js
   jsxCopy Code<Router>
     <div>
       {/* 在这里添加 Link 组件 */}
   
       <Switch>
         <Route exact path="/" component={Home} />
         <Route path="/about" component={About} />
         <Route path="/contact" component={Contact} />
       </Switch>
     </div>
   </Router>
   ```

   在这个例子中，`Router` 组件作为整个路由系统的容器，将所有内容包裹在其中。`Switch` 组件用于从多个路由规则中选择一个进行匹配和渲染。`Route` 组件定义了具体的路由规则，其中 `path` 属性表示匹配的 URL 路径，`component` 属性表示匹配成功后要渲染的组件。

4. 在需要跳转的地方添加 `Link` 组件：

   ```js
   jsxCopy Code<nav>
     <ul>
       <li><Link to="/">Home</Link></li>
       <li><Link to="/about">About</Link></li>
       <li><Link to="/contact">Contact</Link></li>
     </ul>
   </nav>
   ```

   在这个例子中，`Link` 组件会生成一个超链接，可以指向指定的 URL。`to` 属性指定了跳转目标的 URL。

## React Router 项目实践

在 React 项目中使用 React Router 的步骤如下：

1. 安装和引入 React Router：

   ```js
   bashCopy Codenpm install --save react-router-dom
   ```

   ```js
   javascriptCopy Codeimport { BrowserRouter as Router, Route, Link, Switch } from "react-router-dom";
   ```

2. 添加路由规则和组件：

   ```js
   jsxCopy Code<Router>
     <div>
       <nav>
         <ul>
           <li>
             <Link to="/">Home</Link>
           </li>
           <li>
             <Link to="/about">About</Link>
           </li>
           <li>
             <Link to="/topics">Topics</Link>
           </li>
         </ul>
       </nav>
   
       <Switch>
         <Route path="/about" component={About} />
         <Route path="/topics" component={Topics} />
         <Route exact path="/" component={Home} />
         <Route component={NoMatch} />
       </Switch>
     </div>
   </Router>
   ```

   在这个例子中，我们使用 `Route` 组件来定义路由规则和对应的组件。其中，`path` 属性表示匹配的 URL 路径，`component` 属性表示匹配成功后要渲染的组件。

3. 使用 `Link` 组件添加超链接：

   ```js
   jsxCopy Code<Link to="/about">About</Link>
   ```

   在这个例子中，`Link` 组件会生成一个超链接。`to` 属性指定了跳转目标的 URL。在点击该链接时，React Router 将自动触发路由匹配和对应组件的渲染过程。

以上就是基本的 React Router 实践流程。当然，在具体项目中还需要根据实际需求进行适当的调整和扩展。

好的，那我再进一步拓展一下。

### 嵌套路由

在 React Router 中，可以使用嵌套路由来管理子路由。嵌套路由是指将一组路由规则嵌套在另一组路由规则中的方式。例如，在一个电商网站中，可以将所有商品相关的页面都放在 `/products` 路径下，然后在该路由下再定义其他子路由，如 `/products/list`、`/products/detail` 等。

嵌套路由的实现需要在父级路由组件中添加子路由规则，使用 `Route` 组件包裹子路由对应的组件。例如：

```
jsxCopy Code<Route path='/products' component={Products}>
  <Route path='/products/list' component={ProductList} />
  <Route path='/products/detail/:id' component={ProductDetail} />
</Route>
```

在这个例子中，我们首先定义了一个 `/products` 路由规则，对应的组件是 `Products`。然后使用 `Route` 组件添加了两个子路由规则，分别是 `/products/list` 和 `/products/detail/:id`，对应的组件分别是 `ProductList` 和 `ProductDetail`。注意，子路由规则的 `path` 属性需要添加父级路由规则的路径前缀。

### 访问 URL 参数

在 React Router 中，可以通过 URL 参数来传递信息，例如在搜索页面输入关键词后，跳转到搜索结果页面，URL 中可以带上搜索关键词参数，如 `/search?keywords=react`。可以通过 `this.props.location.search` 获取 URL 参数。

另一种获取 URL 参数的方式是使用 React Router 提供的 `match` 对象。`match` 对象是一个包含路由参数信息的对象，包括：

- `params`：一个键值对对象，包含所有 URL 参数的键值对。例如，在 `/users/:id` 路径中，如果访问了 `/users/123`，那么 `params` 对象将包含 `{ id: '123' }`。
- `url`：匹配的 URL 路径。
- `path`：路由规则中定义的路径模板。例如，在 `/users/:id` 路径中，`path` 的值是 `/users/:id`。

可以在路由组件中通过`this.props.match.params`访问 URL 参数。例如，如果定义了一个路径为 `/users/:id` 的路由规则，那么可以在对应组件中通过 `this.props.match.params.id` 访问 ID 参数。

### 重定向

在 React Router 中，可以使用重定向来将不合法的 URL 地址自动重定向到另一个地址。例如，在用户访问某个不存在的页面时，可以将其重定向到网站首页。React Router 提供了 `Redirect` 组件来实现重定向。

```
jsxCopy Code<Switch>
  <Route exact path="/" component={Home} />
  <Route path="/about" component={About} />
  <Redirect from="/old-url" to="/new-url" />
  <Route component={NotFound} />
</Switch>
```

在这个例子中，我们使用 `Redirect` 组件将 `/old-url` 路径重定向到 `/new-url`。`from` 属性表示需要重定向的原始路径，`to` 属性表示重定向后的目标路径。

### 路由守卫

在某些情况下，我们需要根据用户的身份、权限等信息来限制其访问某些页面。React Router 提供了路由守卫（Route Guard）的机制来实现这一需求。路由守卫是钩子函数，在路由匹配时会被触发，可以通过它们来判断是否允许用户访问当前页面。

React Router 中的路由守卫包括三种：

- `Router` 守卫：在整个应用程序中触发，比如在身份验证前检查用户是否已登录。
- `Route` 守卫：在匹配某条具体路由规则时触发，比如在访问某个需要权限的页面时检查当前用户是否有相应的权限。
- 组件守卫：在渲染某个路由对应的组件时触发，比如在访问某个需要管理员权限的组件时检查当前用户是否是管理员。

路由守卫可以通过 `withRouter` 高阶组件来实现。例如，如果要对 `/admin` 路由下所有页面进行权限控制，可以在 `Admin` 组件中定义一个路由守卫：

```
jsxCopy Codeimport { withRouter } from 'react-router-dom';

class Admin extends React.Component {
  componentWillMount() {
    if (!this.props.user.isAdmin) {
      this.props.history.push('/login');
    }
  }

  render() {
    return (
      <div>
        {/* 渲染其他组件 */}
      </div>
    );
  }
}

export default withRouter(Admin);
```

在这个例子中，我们使用 `withRouter` 将 `Admin` 组件包裹，然后在该组件的 `componentWillMount` 方法中判断当前用户是否是管理员。如果不是，则使用 `history.push` 方法将其重定向到登录页面。

以上就是 React Router 的一些进阶使用技巧。在实际项目中，需要根据具体情况选择合适的路由机制和配置。

# 组件库

在软件开发中，模块化和封装是非常重要的概念。组件就是封装好的可复用的程序“零部件”，可以被应用在多个地方。在前端开发中，UI组件是常见的组件形式，如按钮、输入框、下拉选择等都是组件。通过组件和组件的组合，可以构建出更复杂的组件。为了使整个项目UI更统一，降低开发成本，提高开发效率，许多前端开发者会使用已有的UI组件库。

常见的UI组件库有： ElemetUI、vuetify、Ant Design、Bootstrap、Material UI、Vant UI、Framework7、arco.design 等等。这些组件库封装了丰富的UI组件，使开发者可以直接引入并使用，无需自己编写繁琐的样式和逻辑代码。同时，这些UI组件库还提供了丰富的文档和示例，方便开发者快速上手。

除了使用现成的UI组件库，有些公司会根据自身业务需求搭建自己的业务组件库，以达到更好的UI风格统一和更高的开发效率。搭建自己的业务组件库需要考虑到组件的可复用性、易用性和可维护性等因素，同时需要提供丰富的文档和示例以方便开发者使用。

![](https://cdn.jsdelivr.net/gh/kennems/blog-image/20230513225657.png)

![](https://cdn.jsdelivr.net/gh/kennems/blog-image/20230513225641.png)

## 架构设计

### 单包架构

单包架构指的是将所有组件打包成一个整体，发布出去一个npm包的方式。这种方式优点是公共代码易于复用，便于维护和展示更聚合，引入一个包即可使用全部组件。但是缺点也很明显，修改一个组件需要更新整个库，同时需要考虑按需加载。

### 多包架构

多包架构指的是一个代码仓库包含多个组件代码，每个组件会单独发布出去一个npm包。这种方式的优点是可以单独发包，升级灵活，并且在同一仓库下，便于代码管理。同时使用者无需考虑按需加载。但是缺点也存在，当组件间相互依赖时，需要通过npm包引入，组合使用时需要安装每一个用到的npm包。

### 打包速度

对于组件库而言，实时预览非常重要，通常可以使用 Storybook 等工具进行实时预览。

### 样式方案

组件库的样式方案可以选择采用 Less、Sass、CSS in JS 或 CSS，这些技术方案可以满足组件库换肤、样式定制等能力的需求。

### 产物构建

组件库的产物构建工具可以选择 webpack、rollup、vite 或 gulp，产物格式可以选择cjs、umd、es等。

### 质量保障

组件库的测试工具可以选择 jest、karma、mocha、enzyme 和 react-testing-library 等，测试类型可以选择单元测试、快照测试、截屏测试和 e2e 测试等。

### 文档部署

组件库的文档部署可以选择使用 Storybook 或 umijs 等工具展示 Demo，同时也可以使用 markdown 静态内容进行展示。

### 组件API提取

组件API提取方式可以手写或使用自动提取工具如ts-docuemnt等。

### 版本日志生成

组件库的版本日志可以手写，也可以使用自动提取工具从 PR 提交记录自动提取。

## 什么是好的组件？

好的组件应该具有高内聚、低耦合的特点。这意味着一个软件模块由相关性很强的代码组成，只负责一项任务，并且尽可能使其独立存在，减少不同功能或模块之间紧密关系。高内聚和低耦合可以保证服务的独立性以及系统的灵活度。另外，好的组件应具有通用性和易拓展的特点。

## 组件开发-组件组织的好与坏

在组件开发中，组件的命名应该具有语义，并且避免与基础组件冲突，同一团队/仓库下的业务组件，也应采用相同的命名前缀。同时，NPM包名应尽量与组件名保持一致，包含明确的使用场景信息，并且推荐将需要对外导出的TS类型维护在单独的interface.ts中，并将其在index.ts中导出。

## 组件开发-组件设计的好与坏

对于组件的设计，需要注意以下几点：

1. 接口定义：为组件定义接口类型时，应继承原生DOM(或基础组件)属性，避免属性遗漏或重复声明。
2. 类名前缀统一：组件应使用特殊且统一的类名前缀，尽量降低与用户类名冲突的可能性。
3. 避免行内样式和css modules：确保外部可通过类名进行样式覆盖。
4. 避免在js中直接引入样式文件：应尽量保证逻辑与样式的分离，确保用户可以分别引入js和css文件，避免由于构建环境的不同导致的用户编译失败的问题。
5. 注意组件样式的按需加载：在基于基础组件库如Arco进行业务组件的逻辑封装时，应注意按需引入所依赖的Arco基础组件的样式文件。

# 前端技术整体总结

## 前言

学习完青训营的课程，对前端技术有了一定的了解，但对于某些特定技术理解还是不够深刻。所以本文将对现代前端技术的重要侧重点和发展趋势进行分析和总结，对前端技术有一个宏观的认识，今后也会不断学习前端技术。

## 前端技术学习路线

### 初级阶段

初级前端开发人员需要掌握 HTML、CSS 和 JavaScript 的基础知识，以及一些常用的前端框架和库。建议学习以下内容：

- HTML 和 CSS 的基础语法和常用标签和属性
- JavaScript 的基础语法、DOM 操作和事件处理
- 常用的前端框架和库，如 jQuery、Bootstrap 等
- 学习使用开发者工具，如 Chrome 浏览器的检查器

### 中级阶段

中级前端开发人员需要深入了解 HTML、CSS 和 JavaScript，并能够独立完成项目的开发和设计。建议学习以下内容：

- HTML5 和 CSS3 的新特性和应用
- JavaScript 的高级特性和代码优化
- 掌握 React、Vue.js 等主流前端框架和库
- 掌握常见的模块化规范，如 CommonJS、ES6 模块等

### 高级阶段

高级前端开发人员需要具备架构设计和项目管理的能力，并且在某个领域有深入的研究和经验。建议学习以下内容：

- 提高架构设计和代码的可维护性
- 深入研究某个前端领域，如性能优化、组件化开发、移动端开发等
- 学习使用 TypeScript、Webpack 等高级工具和框架
- 掌握前端自动化测试和持续集成等软件开发流程

## 前端技术的重要侧重点

### 用户体验

随着前端技术的发展，用户体验已经成为前端开发的一项关键侧重点。优化用户体验可以通过以下方法来实现：

- 页面加载速度：使用压缩过的资源文件、图像优化、减少网络请求的数量等
- 界面设计：设计简洁明了、易于理解和操作的界面
- 可访问性：确保网站是 barriere-free 的，也就是说对于残障人士也能完全访问和利用
- 可用性：添加导航、搜索框、面包屑和各种调整控件等，使得用户可以方便地使用应用程序

### 响应式设计

响应式设计的目标是确保网站在不同设备上以适当的方式呈现。为了实现响应式设计，需要考虑以下因素：

- 设备尺寸和屏幕分辨率：不同的设备尺寸和屏幕分辨率需要采用不同的设计方案
- CSS 媒体查询：使用 CSS 媒体查询来检测设备屏幕，并动态调整网页布局
- 图像优化：使用合适的图像文件大小和格式，可以提高页面加载速度和性能

### 性能优化

网站性能优化对于提升用户体验、提高搜索引擎排名和降低成本都非常重要。以下是一些性能优化策略：

- 使用缓存技术：使用浏览器缓存和 CDN（内容分发网络）缓存等可以显著提高网站加载时间
- 压缩资源文件：对 HTML、CSS 和 JavaScript 文件进行压缩可以减少文件大小，从而提高加载速度
- 移除不必要的文件：删除不使用的文件和库可以减少 HTTP 请求次数和文件大小，提高网站性能

## 前端技术的发展趋势

### 组件化开发

组件化开发可以将代码分解为小的、独立的部分，可以更方便地维护和重用。以下是一些组件化开发的实践方法：

- 采用框架：使用 Vue.js、React、Angular 等现代框架可以帮助我们快速创建可重用的组件
- 组件库：使用已有的组件库可以节省时间和精力，也可以确保新组件符合当前设计规范
- 单文件组件：使用单文件组件可以将 HTML、CSS 和 JavaScript 组合在一个文件中，使代码易于管理和阅读

### WebAssembly

WebAssembly 是一种新兴的技术，可以让开发人员使用 C、C++、Rust 等语言编写高性能的 Web 应用程序。这些应用程序可以在现代浏览器上运行。以下是 WebAssembly 的一些应用：

- CPU 密集型应用程序：利用 WebAssembly 可以将 CPU 密集型任务转移到客户端，减轻服务器负担
- 密码学和安全：WebAssembly 提供了更高的性能以加密和解密数据，提高了网络传输的安全性
- 游戏开发：WebAssembly 提供了比 JavaScript 更快的运行速度，使得游戏在 Web 上更流畅

### 人工智能和机器学习

人工智能和机器学习是未来前端技术的重要方向之一。以下是一些人工智能和机器学习在前端开发中的应用：

- 自然语言处理：使用机器学习算法可以分析和理解用户输入的信息
- 图像识别：使用深度学习模型和图像处理技术可以对图像进行分析和处理
- 推荐系统：利用机器学习和数据挖掘技术，可以为用户提供个性化的服务和建议

总的来说，以上内容均是现代前端技术中非常重要的内容，掌握这些知识将有助于我们成为合格的前端开发者。

## 结论

总的来说，前端技术是 Web 应用程序的重要组成部分。现代的前端技术不仅注重用户体验，还需要考虑响应式设计和性能优化等方面。未来的前端技术将更加注重组件化开发，采用 WebAssembly 技术和人工智能等技术将会成为一个重要的发展方向。
