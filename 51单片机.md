# 资料结构说明文档



## 1--用户必看  

### 1.1--普中-2&普中-3&普中-4开发板入门教程

### 1.2--KEIL C51软件安装

### 1..3--51仿真器的使用

## 2--开发板原理图 

#### 开发板原理图 

#### 开发板结构图及元器件封装库



## 3--手把手教你学51单片机

### 建议：学习过程中结合《普中51单片机开发攻略》效果更佳

## 4--实验程序 

### 4.1--基础实验-----------------与《普中51单片机开发攻略》实验配套例程

### 4.2--扩展实验-----------------基础实验的扩展，综合应用等

### 4.3--GUI人机实验-------------基于TFTLCD触摸屏实验，里面含有我们原创GUI代码设计，对C语言编程能力要求较高，初学者可后面再学

### 4.4--PZ模块实验--------------里面含有普中51支持的所有模块详细资料与程序

## 5--开发工具 

### 5.1-KEILC51软件----------------------------------------------安装KEILC51的软件包及破解工具

### 5.2-开发板CH340驱动----------------------------------------CH340驱动

### 5.3-程序下载软件---------------------------------------------普中自主开发的自动下载软件PZ-ISP和STC官方软件

### 5.4-常用辅助开发软件-----------------------------------------后续实验中需要使用的一些常用工具 

## 6--芯片资料

### 6.1开发板芯片数据手册

## 7--51相关资料

### C语言加油站-----------------------------------提供C语言入门、深入学习资料

###  扩展LCD资料-----------------------------------MiniLCD12864、LCD9648

## 普中51单片机开发攻略--基于普中-2&普中-3&普中-4

## STC89Cxx中文参考手册.pdf

## 普中-2&普中-3&普中-4开发板资料结构（必看）



# 手把手教你学单片机

1、1

51，AVR，MSP430， STM8， STM32

学习方法：

1、鹦鹉学舌 

2、照葫芦画瓢 

3、他山之石，可以攻玉 

4、理论实践结合，温故而知新

## 键盘选择的方法

```c
u8 key_matrix_flip_scan(void)
{
	static u8 key_value=0;
	KEY_MATRIX_PORT=0x0f;//给所有行赋值0，列全为1
	if(KEY_MATRIX_PORT!=0x0f)//判断按键是否按下
	{
		delay_10us(1000);//消抖
		if(KEY_MATRIX_PORT!=0x0f)
		{
			//测试列
			KEY_MATRIX_PORT=0x0f;
			switch(KEY_MATRIX_PORT)//保存行为0，按键按下后的列值	
			{
				case 0x07: key_value=1;break;
				case 0x0b: key_value=2;break;
				case 0x0d: key_value=3;break;
				case 0x0e: key_value=4;break;
			}
			//测试行
			KEY_MATRIX_PORT=0xf0;
			switch(KEY_MATRIX_PORT)//保存列为0，按键按下后的键值	
			{
				case 0x70: key_value=key_value;break;
				case 0xb0: key_value=key_value+4;break;
				case 0xd0: key_value=key_value+8;break;
				case 0xe0: key_value=key_value+12;break;
			}
			while(KEY_MATRIX_PORT!=0xf0);//等待按键松开	
		}
	}
	else
		key_value=0;		
	return key_value;		
}

u8 key_matrix_ranks_scan(void)
{
	u8 key_value=0;
	KEY_MATRIX_PORT=0xf7;//给第一列赋值0，其余全为1
	if(KEY_MATRIX_PORT!=0xf7)//判断第一列按键是否按下
	{
		delay_10us(1000);//消抖
		switch(KEY_MATRIX_PORT)//保存第一列按键按下后的键值	
		{
			case 0x77: key_value=1;break;
			case 0xb7: key_value=5;break;
			case 0xd7: key_value=9;break;
			case 0xe7: key_value=13;break;
		}
	}
	while(KEY_MATRIX_PORT!=0xf7);//等待按键松开	
	KEY_MATRIX_PORT=0xfb;//给第二列赋值0，其余全为1
	if(KEY_MATRIX_PORT!=0xfb)//判断第二列按键是否按下
	{
		delay_10us(1000);//消抖
		switch(KEY_MATRIX_PORT)//保存第二列按键按下后的键值	
		{
			case 0x7b: key_value=2;break;
			case 0xbb: key_value=6;break;
			case 0xdb: key_value=10;break;
			case 0xeb: key_value=14;break;
		}
	}
	while(KEY_MATRIX_PORT!=0xfb);//等待按键松开	
	KEY_MATRIX_PORT=0xfd;//给第三列赋值0，其余全为1
	if(KEY_MATRIX_PORT!=0xfd)//判断第三列按键是否按下
	{
		delay_10us(1000);//消抖
		switch(KEY_MATRIX_PORT)//保存第三列按键按下后的键值	
		{
			case 0x7d: key_value=3;break;
			case 0xbd: key_value=7;break;
			case 0xdd: key_value=11;break;
			case 0xed: key_value=15;break;
		}
	}
	while(KEY_MATRIX_PORT!=0xfd);//等待按键松开	
	KEY_MATRIX_PORT=0xfe;//给第四列赋值0，其余全为1
	if(KEY_MATRIX_PORT!=0xfe)//判断第四列按键是否按下
	{
		delay_10us(1000);//消抖
		switch(KEY_MATRIX_PORT)//保存第四列按键按下后的键值	
		{
			case 0x7e: key_value=4;break;
			case 0xbe: key_value=8;break;
			case 0xde: key_value=12;break;
			case 0xee: key_value=16;break;
		}
	}
	while(KEY_MATRIX_PORT!=0xfe);//等待按键松开
	return key_value;		
}
```

# 通信

- 串行通信

- 并行通信



- 同步通信
  - 时钟相同

- 异步通信



- 单工通信

- 半双工通信
