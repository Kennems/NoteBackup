# 算法竞赛进阶指南全记录

题目合辑很多网站上都有，校oj上有，acwing和牛客也有，优先校oj上做题，不全的再找别的网站。计划往往不能完成，但是还是要有的。目标11月前刷完本书。

## 0x00

### 问题 A: 【快速幂】a^b

基础模板题

```c++

```

### 问题 B: 64位整数乘法

### 问题 C: 最短Hamilton路径

### 问题 D: Raising Modulo Numbers

### 问题 E: Strange Towers of Hanoi

### 问题 F: 费解的开关

思维题，本质dfs。第一层的开关闭合排列为2^5=32（五个位置分别可以开或关，五位数的二进制数）,遍历每一种开关方案，之后用上下左右本身五个方向dfs如果本行为0则按下下方开关，以此类推，最后一行也唯一确定，判断最后一行是否符合，符合则更新答案。先确定第一行之后依次确定则能确定所有可能的情况。

```c++
#include<bits/stdc++.h>
using namespace std;
#define int long long 
#define endl "\n"
int ans,flag,cur,t;
const int INF=0x3f3f3f3f;
char te[15][15];
int g[15][15],backup[15][15];
int dx[5]={0,0,-1,0,1},dy[5]={0,1,0,-1,0};
void turn(int x,int y){
	for(int i=0;i<5;i++){
		int xx=x+dx[i]; int yy=y+dy[i];
		if(xx<1||xx>5||yy<1||yy>5){
			continue;
		}
		else g[xx][yy]^=1;
	}
}
int work(){
	ans=INF;
	for(int k=0;k< (1<<5) ;k++){
		cur=0; flag=0;
		backup[15][15];
		memcpy(backup,g,sizeof g);
		for(int j=0;j<5;j++){ //先确定第一行五个开关的所有开关情况
			if((k>>j)&1){
				turn(1,j+1);
				cur++;
			}
		}
		for(int i=1;i<=4;i++){
			for(int j=1;j<=5;j++){
				if(g[i][j]==0){
					cur++;
					turn(i+1,j);
				}
			}
		}
		for(int j=1;j<=5;j++){
			if(g[5][j]==0){
				flag=1;
				break;
			}
		}
		if(!flag){
			ans=min(ans,cur);
		}
		memcpy(g,backup,sizeof backup);
	}
	return ans;
}
signed main()
{
	ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
	cin>>t;
	while(t--){
		for(int i=0;i<5;i++){
			cin>>te[i];
		}
		for(int i=1;i<=5;i++){
			for(int j=1;j<=5;j++){
				g[i][j]=te[i-1][j-1]-'0';
			}
		}
		ans=work();
		if(ans==INF||ans>6){
			cout<<-1<<endl;
		}
		else cout<<ans<<endl;
	}
	return 0;
}
```



### 问题 G: 激光炸弹

```c++
#include<bits/stdc++.h>
using namespace std;
#define endl "\n"
const int maxn=5e3+10;
int n,r,ma=-1,x,y,v,sum;
int g[maxn][maxn];
signed main()
{
	ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
	cin>>n>>r;
	for(int i=1;i<=n;i++){
		cin>>x>>y>>v;
		x++; y++;
		g[x][y]+=v;
		sum+=v;
	}
	if(r>=n){
		cout<<sum<<endl;
		return 0;
	}
	for(int i=1;i<=5001;i++){
		for(int j=1;j<=5001;j++){
			g[i][j]=g[i][j]+g[i-1][j]+g[i][j-1]-g[i-1][j-1];
		}
	}
	for(int i=r;i<=5001;i++){
		for(int j=r;j<=5001;j++){
			ma=max(ma,g[i][j]-g[i][j-r]-g[i-r][j]+g[i-r][j-r]);
		}
	}
	cout<<ma<<endl;
	return 0;
}
```



### 问题 H: Tallest Cow

```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e7+100;
int n,i,h,r,a,b;
int d[maxn];
map<pair<int,int>,bool> existed;
signed main()
{
	cin>>n>>i>>h>>r;
	for(i=1;i<=r;i++){
		cin>>a>>b;
		if(a>b){
			swap(a,b);
		}
		if(existed[make_pair(a,b)]) continue;
		d[a+1]+=1; d[b]-=1;
		existed[make_pair(a,b)]=true;
	}
	for(int i=1;i<=n;i++){
		d[i]=d[i-1]+d[i];
		cout<<h+d[i]<<endl;
	}
	cout<<endl;
	return 0;
}
```



### 问题 I: 递归／非递归实现组合型枚举

### 问题 K: 递归实现排列型枚举

```c++
#include<bits/stdc++.h>
using namespace std;
#define int long long 
#define endl "\n"
int ord[20]; //顺序 
bool f[20]; //检查是否访问过 
int n;
void c(int k){ //solve函数 
	if(k==n+1){
		for(int i=1;i<=n;i++){
			cout<<ord[i]<<' ';
		}
		cout<<endl;
		return ;
	}
	for(int i=1;i<=n;i++){
		if(f[i]) continue;
		ord[k]=i;
		f[i]=1;
		c(k+1);
		f[i]=0;
		ord[k]=0;
	}
}
signed main()
{
	ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
	cin>>n;
	c(1);
	return 0;
}

```

