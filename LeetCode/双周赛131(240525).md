---
title : 'LeetCodeåŒå‘¨èµ›131(240525)'
date : 2024-05-27T15:37:01+08:00
lastmod: 2024-05-27T15:37:01+08:00
description : "LeetCode åŒå‘¨èµ› 131(240525)" 
image : img/cat.jpg
draft : false    
categories : ["LeetCode"]
tags : ["LeetCodeå‘¨èµ›"]
# password : leetcode
---


# åŒå‘¨èµ›131(240525)

AKçš„ç¬¬äºŒåœºðŸ˜ï¼Œ ç¬¬å››é¢˜æ˜¯ç”¨C++ æ‰¾ç½‘ä¸Šæ¨¡æ¿ï¼Œå¥—ç”¨æŸ¥æ‰¾æœ€é•¿çš„è¿ž0ä¸²è¿‡çš„ï¼Œ æœ€åŽä¸¤åˆ†é’Ÿæ‰è¿‡ï¼Œå¾ˆæƒŠé™©ã€‚èµ›åŽå‘çŽ°åšæ³•å¹¶ä¸ä¼˜ç§€ï¼Œä½†æ˜¯ä¸éœ€è¦å¹³è¡¡æ ‘ã€‚

## [3161. ç‰©å—æ”¾ç½®æŸ¥è¯¢](https://leetcode.cn/problems/block-placement-queries/)

**é¢˜ç›®å¤§æ„ï¼š**

æœ‰ä¸€æ¡æ— é™é•¿çš„æ•°è½´ï¼ŒåŽŸç‚¹åœ¨ 0 å¤„ï¼Œæ²¿ç€ x è½´æ­£æ–¹å‘æ— é™å»¶ä¼¸ã€‚ç»™å®šä¸€ä¸ªäºŒç»´æ•°ç»„ queries åŒ…å«ä¸¤ç§æ“ä½œï¼š

1. æ“ä½œç±»åž‹ 1ï¼šåœ¨è·ç¦»åŽŸç‚¹ x å¤„å»ºä¸€ä¸ªéšœç¢ç‰©ã€‚
2. æ“ä½œç±»åž‹ 2ï¼šåˆ¤æ–­åœ¨æ•°è½´èŒƒå›´ [0, x] å†…æ˜¯å¦å¯ä»¥æ”¾ç½®ä¸€ä¸ªé•¿åº¦ä¸º sz çš„ç‰©å—ï¼Œè¯¥ç‰©å—éœ€è¦å®Œå…¨æ”¾ç½®åœ¨èŒƒå›´ [0, x] å†…ã€‚å¦‚æžœç‰©å—ä¸Žä»»ä½•éšœç¢ç‰©æœ‰é‡åˆï¼Œåˆ™è¯¥ç‰©å—ä¸èƒ½è¢«æ”¾ç½®ï¼Œä½†ç‰©å—å¯ä»¥ä¸Žéšœç¢ç‰©åˆšå¥½æŽ¥è§¦ã€‚

å¯¹äºŽæ“ä½œç±»åž‹ 2 çš„æŸ¥è¯¢ï¼Œè‹¥å¯ä»¥æ”¾ç½®ç‰©å—ï¼Œåˆ™è¿”å›ž trueï¼Œå¦åˆ™è¿”å›ž falseã€‚

**å®žçŽ°æ€è·¯ï¼š**

1. **çº¿æ®µæ ‘çš„æž„å»ºå’Œç»´æŠ¤ï¼š**
   - ä½¿ç”¨ä¸€ä¸ªæ•°ç»„ `tr` æ¥è¡¨ç¤ºçº¿æ®µæ ‘ï¼Œåˆå§‹åŒ–ä¸ºå…¨é›¶ã€‚æ•°ç»„çš„é•¿åº¦å¯ä»¥é€šè¿‡æŸ¥è¯¢ä¸­çš„æœ€å¤§èŒƒå›´ç¡®å®šï¼Œå³ `m = max(q[1] for q in queries)`ã€‚
   - å®šä¹‰ `pushup` å‡½æ•°ç”¨äºŽæ›´æ–°çº¿æ®µæ ‘ä¸­çš„èŠ‚ç‚¹ä¿¡æ¯ï¼Œæ¯å½“ä¿®æ”¹çº¿æ®µæ ‘ä¸­æŸä¸ªèŠ‚ç‚¹çš„å€¼æ—¶è°ƒç”¨ã€‚
   - å®šä¹‰ `modify` å‡½æ•°ç”¨äºŽä¿®æ”¹çº¿æ®µæ ‘ä¸­çš„å€¼ï¼Œå°†æŸä¸ªä½ç½®çš„å€¼æ›´æ–°ä¸ºæ–°å€¼ï¼Œå¹¶æ ¹æ®éœ€è¦é€’å½’æ›´æ–°çˆ¶èŠ‚ç‚¹çš„ä¿¡æ¯ã€‚
   - å®šä¹‰ `query` å‡½æ•°ç”¨äºŽæŸ¥è¯¢çº¿æ®µæ ‘ä¸­æŸä¸ªåŒºé—´å†…çš„æœ€å¤§å€¼ã€‚

2. **Sorted List çš„ç»´æŠ¤ï¼š**
   - ä½¿ç”¨ SortedList ç»“æž„æ¥ç»´æŠ¤éšœç¢ç‰©çš„ä½ç½®ä¿¡æ¯ï¼ŒSortedSet æ˜¯ä¸€ä¸ªæœ‰åºçš„é›†åˆæ•°æ®ç»“æž„ã€‚
   - åœ¨æ“ä½œç±»åž‹ 1 ä¸­ï¼Œå³æ·»åŠ éšœç¢ç‰©æ—¶ï¼Œä½¿ç”¨ `bisect_left` æ‰¾åˆ°åº”è¯¥æ’å…¥çš„ä½ç½®ï¼Œå¹¶åœ¨ç›¸åº”çš„ä½ç½®æ’å…¥æ–°çš„éšœç¢ç‰©ä½ç½®ï¼Œå¹¶æ›´æ–°çº¿æ®µæ ‘çš„ä¿¡æ¯ã€‚

3. **æŸ¥è¯¢æ“ä½œç±»åž‹ 2ï¼š**
   - å¯¹äºŽæ¯ä¸€ä¸ªæ“ä½œç±»åž‹ 2 çš„æŸ¥è¯¢ï¼Œå…ˆæ‰¾åˆ°è¯¥ä½ç½®ä¹‹å‰æœ€è¿‘çš„éšœç¢ç‰©çš„ä½ç½® `pre`ï¼Œç„¶åŽé€šè¿‡çº¿æ®µæ ‘æŸ¥è¯¢è¯¥åŒºé—´å†…çš„æœ€å¤§å€¼ã€‚
   - å¦‚æžœè¯¥å€¼å¤§äºŽç­‰äºŽæ‰€éœ€æ”¾ç½®ç‰©å—çš„å¤§å°ï¼Œåˆ™è¯´æ˜Žå¯ä»¥æ”¾ç½®ç‰©å—ï¼Œå¦åˆ™ä¸è¡Œã€‚

```py
from sortedcontainers import SortedList
class Solution:
    def getResults(self, queries: List[List[int]]) -> List[bool]:
        m = max(q[1] for q in queries)
        tr = [0]*(1<<m.bit_length() + 1)

        def pushup(u):
            tr[u] = max(tr[u<<1], tr[u<<1|1])

        def modify(u, l, r, x, val):
            if l==r:
                tr[u] = val
            else:
                mid = l+r>>1
                if x<=mid:
                    modify(u<<1, l, mid, x, val)
                else:
                    modify(u<<1|1, mid+1, r, x, val)
                pushup(u)
            
        def query(u, l, r, ql, qr):
            if ql<=l and r<=qr:
                return tr[u]
            
            mid = l+r>>1
            res = 0

            if ql<=mid:
                res = query(u<<1, l, mid, ql, qr)
            if qr>mid:
                res = max(res, query(u<<1|1, mid+1, r, ql, qr))
            
            return res

        sl = SortedList([0, m])
        res = []
        for q in queries:
            x = q[1]
            i = sl.bisect_left(x)
            pre = sl[i-1]
            if q[0]==1:
                nxt = sl[i]
                sl.add(x)
                modify(1, 0, m, x, x-pre)
                modify(1, 0, m, nxt, nxt-x)
            else:
                sz = q[2]
                ans = max(x-pre, query(1, 0, m, 0, pre))
                res.append(ans >= sz)

        return res

```

æ¯”èµ›æ—¶çš„åšæ³•ï¼Œæœ¬æ¥æ˜¯C++ï¼Œè½¬æˆäº†python

```py
class Node:
    def __init__(self):
        self.l = 0
        self.r = 0
        self.d = 0
        self.ld = 0
        self.rd = 0
        self.low = -1

class Solution:
    def getResults(self, queries):
        def build(u, l, r):
            tr[u].l = l
            tr[u].r = r
            tr[u].d = r - l + 1
            tr[u].ld = r - l + 1
            tr[u].rd = r - l + 1
            tr[u].low = -1
            if l != r:
                mid = (l + r) >> 1
                build(u << 1, l, mid)
                build(u << 1 | 1, mid + 1, r)

        def pushup(u):
            tr[u].ld = tr[u << 1].ld
            if tr[u << 1].ld == tr[u << 1].r - tr[u << 1].l + 1:
                tr[u].ld += tr[u << 1 | 1].ld

            tr[u].rd = tr[u << 1 | 1].rd
            if tr[u << 1 | 1].rd == tr[u << 1 | 1].r - tr[u << 1 | 1].l + 1:
                tr[u].rd += tr[u << 1].rd

            tr[u].d = max(max(tr[u << 1].d, tr[u << 1 | 1].d), tr[u << 1].rd + tr[u << 1 | 1].ld)

        def pushdown(u):
            if tr[u].low == -1:
                return

            tr[u << 1].low = tr[u << 1 | 1].low = tr[u].low
            if tr[u].low:
                tr[u << 1].d = tr[u << 1].ld = tr[u << 1].rd = 0
                tr[u << 1 | 1].d = tr[u << 1 | 1].ld = tr[u << 1 | 1].rd = 0
            else:
                tr[u << 1].d = tr[u << 1].ld = tr[u << 1].rd = tr[u << 1].r - tr[u << 1].l + 1
                tr[u << 1 | 1].d = tr[u << 1 | 1].ld = tr[u << 1 | 1].rd = tr[u << 1 | 1].r - tr[u << 1 | 1].l + 1
            tr[u].low = -1

        def query(u, ql, qr):
            if tr[u].l > qr or tr[u].r < ql:
                return 0
            if tr[u].l >= ql and tr[u].r <= qr:
                return tr[u].d

            pushdown(u)

            mid = (tr[u].l + tr[u].r) >> 1
            res = 0
            if ql <= mid:
                res = max(res, query(u << 1, ql, qr))
            if qr > mid:
                res = max(res, query(u << 1 | 1, ql, qr))

            # Cross left and right subintervals handling
            if ql <= mid and qr > mid:
                left_suffix = min(tr[u << 1].rd, mid - ql + 1)
                right_prefix = min(tr[u << 1 | 1].ld, qr - mid)

                res = max(res, left_suffix + right_prefix)

            return res

        def modify(u, l, r, d):
            if tr[u].l >= l and tr[u].r <= r:
                if d:
                    tr[u].d = tr[u].ld = tr[u].rd = 0
                    tr[u].low = 1
                else:
                    tr[u].d = tr[u].ld = tr[u].rd = tr[u].r - tr[u].l + 1
                    tr[u].low = 0
                return

            pushdown(u)
            mid = (tr[u].l + tr[u].r) >> 1
            if l <= mid:
                modify(u << 1, l, r, d)
            if r > mid:
                modify(u << 1 | 1, l, r, d)
            pushup(u)

        n = max(q[1] for q in queries)
        tr = [Node() for _ in range(1<<n.bit_length() + 1)]
        build(1, 0, n)

        res = []
        modify(1, 0, 0, 1)
        mp = {}

        for q in queries:
            if q[0] == 1:
                x = q[1]
                modify(1, x, x, 1)
                mp[x] = 1
            else:
                x = q[1]
                sz = q[2]

                if x < sz:
                    res.append(False)
                    continue

                if mp.get(x) != 1:
                    modify(1, x, x, 1)

                ans = query(1, 0, x)
                
                if mp.get(x) != 1:
                    modify(1, x, x, 0)

                res.append(ans >= sz-1)

        return res
```

