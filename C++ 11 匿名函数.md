# C++ 11 匿名函数

## Lambda

```c++
1、 [ captures ] (params) specifiers exception attr -> ret {body} 
2、 [ captures ] (params) ->ret {body}
3、 [ captures ] (params) {body}
4、 [ captures ] {body}
```

- captures : 捕获参数

| 格式    | 意义                                            |
| ------- | :---------------------------------------------- |
| []      | 默认不捕获任何变量                              |
| [=]     | 默认以值捕获所有变量                            |
| [&]     | 默认以引用捕获所有变量                          |
| [x]     | 仅以值捕获x，其它变量不捕获                     |
| [&x]    | 仅以引用捕获x，其它变量不捕获                   |
| [=, &x] | 默认以值捕获所有变量，但是x是例外，通过引用捕获 |
| [&, x]  | 默认以引用捕获所有变量，但是x是例外，通过值捕获 |
| [this]  | 通过引用捕获当前对象（其实是复制指针）          |
| [*this] | 通过传值方式捕获当前对象                        |

- params：参数列表。
- ret：返回类型。
- body：函数体。
- specifiers：限定符列表。比如mutable。
- exception：异常规定。比如noexcept。
- attr：属性规定，[详见](https://zh.cppreference.com/w/cpp/language/attributes)。

值传递无法修改局部变量，而引用传递可以改变

如果需要修改值传递的局部变量需要`motable`

```c++
auto lambda1 = [=]() mutable{
    num_1 = 10;
    num_2 = 20;
    num_3 = 30;
    //函数体内只能使用外部变量，而无法对它们进行修改
    cout << num_1 << " "
         << num_2 << " "
         << num_3 << endl;
};
```

