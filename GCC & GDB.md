# GCC & GDB

gcc 与 g++ 分别是 gnu 的 c & c++ 编译器 gcc/g++ 在执行编译工作的时候，总共需要4步：

- 1、预处理,生成 .i 的文件[**预处理器cpp**]
- 2、将预处理后的文件转换成汇编语言, 生成文件 .s [**编译器egcs**]
- 3、有汇编变为目标代码(机器代码)生成 .o 的文件[**汇编器as**]
- 4、连接目标代码, 生成可执行程序 [**链接器ld**]

## GCC

## 1、设定文件所使用的语言 -x

可以编译不是指定文件后缀的文件，.c .cpp

```bash
gcc -x language filename
```

```bash
gcc -x none filename
```

## 2、只把程序做成obj文件 -c

```bash
gcc -c hello.c
```

## 3、只激活预处理和编译，编译为汇编代码 -S

```bash
gcc -S hello.c
```

## 4、只激活预处理，不生成文件 -E

```bash
gcc -E hello.c > text.txt
gcc -E hello.c | more
```

## 5、指定目标名称，默认编译出a.out -o

```bash
gcc -o ExecuteFileName hello.c
```

## 6、使用管道代替编译中临时文件 -pipe

使用非GNU汇编工具的时候，可以会有问题。

```bash 
gcc -pipe -o hello.exe hello.c
```

## 7、使用某个文件，-include

相当于在代码中使用#include<filename>

```bash
gcc hello.c -include /root/tmp.h
```

## 8、预处理是不删除注释信息，一般和-E使用 -C



## 9、生成文件关联的信息 -M

和-M的那个一样，但是它将忽略由 **#include<file>** 造成的依赖关系。 　　

```bash
-MD
```

和-M相同，但是输出将导入到.d的文件里面 　　

```bash
-MMD
```

和 -MM 相同，但是输出将导入到 .d 的文件里面。

## 10、制定编译的时候使用的库 **-llibrary**

　　

例子用法

　　

```
gcc -lcurses hello.c
```

　　

使用 ncurses 库编译程序

## GDB

1. **支持多种编程语言：** GDB 可以用于调试多种编程语言的程序，包括但不限于 C、C++、Java 和 Pascal。
2. **远程调试功能：** GDB 提供远程调试功能，这对嵌入式系统非常有用。你可以通过网络连接到远程目标，并对其进行调试，设置断点，检查内存，交换信息等。
3. **远程串行调试信息：** GDB 可以显示自身和所调试的目标之间的远程串行调试信息。此外，你还可以选择将这些信息记录到日志文件中，以便后续分析。
4. **求解表达式：** 在 GDB 中，你可以在控制台中输入任意 C 表达式，并求解其值。这包括包含远程目标的函数调用等。
5. **脚本语言支持：** GDB 具有脚本语言支持，允许你编写脚本以自动设置和检测目标。这使得自动化调试任务变得更加容易。
6. **跟踪点功能：** GDB 提供跟踪点的功能，可以记录运行程序的信息而尽可能地不打断程序。这允许你收集数据而不影响程序的正常执行。

启动GDB调试有多种方式，以下是其中三种常见的方式：

1. **通过指定程序名称启动：**

   ```
   gdb <program>
   ```

   其中 `<program>` 是你要调试的执行文件的名称。通常，该文件应该在当前工作目录中，或者你可以提供完整的路径。

2. **通过指定程序名称和核心转储文件启动：**

   ```bash
   gdb <program> core
   ```

   如果程序在运行时发生了崩溃或非法执行，并生成了核心转储文件（core dump），你可以使用这种方式同时调试程序和核心文件。`<program>` 是执行文件的名称，而 `core` 是核心文件的名称。

3. **通过指定程序名称和进程ID启动：**

   ```shell
   gdb <program> <PID>
   ```

   如果你的程序是一个服务程序，已经在运行，并且你知道它的进程ID（PID），你可以使用这种方式将 GDB 附加到正在运行的进程上。GDB 会自动连接到指定的进程，并开始调试。 `<program>` 是执行文件的名称，而 `<PID>` 是进程ID。

### 生成可执行文件具有调试信息。

```bash
gcc –o AppTest –g AppTest.c
```

### 常用命令：

- `list` 或 `l`（显示代码）
  - `list`：显示当前位置周围的源代码。
  - `list main`：显示 `main` 函数的源代码。
  - `list 20`：显示第 20 行附近的源代码。
- `run` 或 `r`（从程序开头运行）
  - `run`：从程序的开头开始运行。
  - `run file1.txt file2.txt`：带参数运行程序。
- `next` 或 `n（执行下一行，跳过函数调用）
- `step` 或 `s`（执行下一行，进入函数调用）
- `break` 或 `b`（设置断点）
  - `break main`：在 `main` 函数处设置断点。
  - `break 10`：在第 10 行设置断点。
- `delete` 或 `d`（删除断点）
  - `delete`：删除所有断点。
  - `delete 2`：删除编号为 2 的断点。
- `continue` 或 `c`（在停止时继续执行）
- `print` 或 `p`（打印值）
  - `print x`：打印变量 `x` 的值。
  - `print x*y`：计算并打印 `x * y` 的值。
  - `print function(x)`：调用函数并打印结果。
- `display`（持续显示值）
- `undisplay`（移除显示的值）
- `where`（显示当前函数调用栈）
- `set`（改变一个值）
  - `set var n=3`：将变量 `n` 的值设置为 3。
- `help` 或 `h`（显示帮助文本）
  - `help`：显示所有可用命令的帮助。
  - `help step`：显示关于 `step` 命令的帮助信息。
  - `help breakpoints`：显示关于断点的帮助信息。
- `quit` 或 `q`（退出 GDB）

## 1. 入门三步曲

### 1.1 设断点

如果你曾经使用过调试器, 那你可能已经会设置断点了。 下面是一个我们要调试的程序(虽然没有任何 Bug):

```c
#include <stdio.h>
void do_thing() {
 printf("Hi!\n");
}
int main() {
 do_thing();
}
```

另存为 hello.c. 我们可以使用 dbg 调试它, 像这样:

```bash
bork@kiwi ~> gcc -g hello.c -o hello
bork@kiwi ~> gdb ./hello
```

以上是带调试信息编译 hello.c(为了 gdb 可以更好工作), 并且它会给我们醒目的提示符, 就像这样: `(gdb)` 我们可以使用 break 命令设置断点, 然后使用 run 开始调试程序。

```bash
(gdb) break do_thing 
Breakpoint 1 at 0x4004f8
(gdb) run
Starting program: /home/bork/hello 
Breakpoint 1, 0x00000000004004f8 in do_thing ()
```

程序暂停在了 do_thing 开始的地方。 我们可以通过 where 查看我们所在的调用栈。

```bash
(gdb) where
#0 do_thing () at hello.c:3
#1 0x08050cdb in main () at hello.c:6
(gdb)
```

### 1.2 阅读汇编代码

使用 disassemble 命令, 我们可以看到这个函数的汇编代码。棒级了, 这是 x86 汇编代码。虽然我不是很懂它, 但是 callq 这一行是 printf 函数调用。

```bash
(gdb) disassemble do_thing
Dump of assembler code for function do_thing:
 0x00000000004004f4 <+0>: push %rbp
 0x00000000004004f5 <+1>: mov %rsp,%rbp
=> 0x00000000004004f8 <+4>: mov $0x40060c,%edi
 0x00000000004004fd <+9>: callq 0x4003f0 
 0x0000000000400502 <+14>: pop %rbp
 0x0000000000400503 <+15>: retq
```

你也可以使用 disassemble 的缩写 disas。

### 1.3 查看内存

当调试我的内核时, 我使用 gdb 的主要原因是, 以确保内存布局是如我所想的那样。检查内存的命令是 examine, 或者使用缩写 x。我们将使用x。 通过阅读上面的汇编代码, 似乎 0x40060c 可能是我们所要打印的字符串地址。我们来试一下。

```bash
(gdb) x/s 0x40060c
0x40060c: "Hi!"
```

的确是这样。x/s 中 /s 部分, 意思是"把它作为字符串展示"。我也可以"展示 10 个字符", 像这样:

```bash
(gdb) x/10c 0x40060c
0x40060c: 72 'H' 105 'i' 33 '!' 0 '\000' 1 '\001' 27 '\033' 3 '\003' 59 ';'
0x400614: 52 '4' 0 '\000'
```

你可以看到前四个字符是 H、i、! 和 \0, 并且它们之后的是一些不相关的东西。

## 2. gdb参数+命令 说明

### 2.1 gdb 参数

-cd: 设置工作目录; -q: 安静模式, 不打印介绍信息和版本信息; -d: 添加文件查找路径; -x: 从指定文件中执行GDB指令; -s: 设置读取的符号表文件。

### 2.2 gdb 命令

| 命令                                                       |                             解释                             | 示例                                                         |
| ---------------------------------------------------------- | :----------------------------------------------------------: | ------------------------------------------------------------ |
| file <文本名>                                              | 加载被调试的可执行程序文件。因为一般都在被调试程序所在目录下执行GDB, 因而文本名不需要带路径。 | (gdb) file gdb-sample                                        |
| r                                                          | Run的简写, 运行被调试的程序。如果此前没有下过断点, 则执行完整个程序; 如果有断点, 则程序暂停在第一个可用断点处。 | (gdb) r                                                      |
| c                                                          | Continue的简写, 继续执行被调试程序, 直至下一个断点或程序结束。 | (gdb) c                                                      |
| b <行号> b <函数名称> b *<函数名称> b *<代码地址> d [编号] | b: Breakpoint的简写, 设置断点。 可以使用"行号"“函数名称"“执行地址"等方式指定断点位置。 其中在函数名称前面加”*“符号表示将断点设置在"由编译器生成的prolog代码处”。如果不了解汇编, 可以不予理会此用法。 d: Delete breakpoint的简写, 删除指定编号的某个断点, 或删除所有断点。断点编号从1开始递增。 | (gdb) b 8 (gdb) b main (gdb) b *main (gdb) b *0x804835c (gdb) d |
| s, n                                                       | s: 执行一行源程序代码, 如果此行代码中有函数调用, 则进入该函数; n: 执行一行源程序代码, 此行代码中的函数调用也一并执行。 s 相当于其它调试器中的"Step Into (单步跟踪进入)"; n 相当于其它调试器中的"Step Over (单步跟踪)"。 这两个命令必须在有源代码调试信息的情况下才可以使用(GCC编译时使用”-g"参数)。 | (gdb) s (gdb) n                                              |
| si, ni                                                     | si命令类似于s命令, ni命令类似于n命令。所不同的是, 这两个命令(si/ni)所针对的是汇编指令, 而s/n针对的是源代码。 | (gdb) si (gdb) ni                                            |
| p <变量名称>                                               |     Print的简写, 显示指定变量(临时变量或全局变量)的值。      | (gdb) p i (gdb) p nGlobalVar                                 |
| display … undisplay <编号>                                 | display, 设置程序中断后欲显示的数据及其格式。 例如, 如果希望每次程序中断后可以看到即将被执行的下一条汇编指令, 可以使用命令 “display /i $pc” 其中 $pc 代表当前汇编指令, /i 表示以十六进行显示。当需要关心汇编代码时, 此命令相当有用。 undispaly, 取消先前的display设置, 编号从1开始递增。 | (gdb) display /i $pc (gdb) undisplay 1                       |
| i                                                          |      info的简写, 用于显示各类信息, 详情请查阅"help i"。      | (gdb) i r                                                    |
| q                                                          |                Quit的简写, 退出GDB调试环境。                 | (gdb) q                                                      |
| help [命令名称]                                            | GDB帮助命令, 提供对GDB名种命令的解释说明。 如果指定了"命令名称"参数, 则显示该命令的详细说明; 如果没有指定参数, 则分类显示所有GDB命令, 供用户进一步浏览和查询。 | (gdb) help                                                   |
| l                                                          | list的简写, 列出10行代码, 再次输入则列出往下的10行。若是list 加行号则从该行开始输出10行 | (gdb) l                                                      |
| watch                                                      | watch 为表达式(变量)expr设置一个观察点。变量量表达式值有变化时, 马上停住程序 | (gdb) watch a*b + c/d                                        |
| finish                                                     | 运行至当前函数结束, 并打印函数返回时的堆栈地址和返回值及参数值等信息 |                                                              |
| set args                                                   |                   可以修改发送给程序的参数                   | (gdb)set args –b –x                                          |
| show args                                                  |                     查看其缺省参数的列表                     | (gdb) show args                                              |
| whatis                                                     |                      显示某个变量的类型                      | (gdb) whatis p                                               |

### 2.3 机器语言工具

有一组专用的gdb变量可以用来检查和修改计算机的通用寄存器, gdb提供了目前每一台计算机中实际使用的4个寄存器的标准名字:

- l $pc : 程序计数器
- l $fp : 帧指针(当前堆栈帧)
- l $sp : 栈指针
- l $ps : 处理器状态