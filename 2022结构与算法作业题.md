2022结构与算法作业题

cmd默认使用GBK2312 代码编号是936，使用chcp查看，修改为utf-8

```bash
chcp 65001
```



# 0）顺序表

## [(46条消息) 作业0：顺序表的基本操作_yangcomesteve的博客-CSDN博客](https://blog.csdn.net/qq_28328931/article/details/51492931)

```c++
# include <stdio.h>
# include <stdlib.h>
# include <stdbool.h>
#define MAXSIZE 1024
typedef int elemtype;
typedef struct List
{
	int Data[MAXSIZE];
	int length;
	
}list,*List;
List InitList()
{
  	List L=(List)malloc(sizeof(list));	
	if(L==NULL){
		return NULL;
	}
	  L->length=0;	
	  return L;
}
int GetData(List L,int data)//输入数据
{
	if (L->length >= MAXSIZE)
	{
		printf("顺序表已满\n");
		return 0;
	}
	L->Data[L->length++] = data;
	return 1;
}
int FindByP(List L,int i)//定位查找
{
	if (i<1 || i>L->length)
	{
	   printf("位置非法\n");
		return 0;
	}
	 printf("该位置的数据为 %d\n",L->Data[i - 1]);
	return 1;
}
int FindBydata(List L,int data)//按值查找,数据存在则返回数据位置，不存在则返回0
{       int i;
	for (i = 0; i < L->length; i++)
		if (L->Data[i] == data)
		{
		   printf("数据所在位置是 %d \n",i + 1);
			return 1;
		}
	 printf("数据 %d 不存在\n",data);
	return 0;
}
void Put(List L)//输出顺序表中的数据
{     int i;
	if (L->length == 0)
	 printf("顺序表为空表！\n");
	else
		for (i = 0; i < L->length; i++)
		printf("%d ",L->Data[i]);
}
int Insert(List L,int i,int x)//按位插入数据
{        int n;
	if (L->length >= MAXSIZE)
	{
		printf("顺序表空间满，插入失败\n");  
		return -1;
	}
	if (i<1 || i>L->length)
	{
		printf("插入位置非法，插入失败\n");
		return 0;
	}
	for ( n = L->length; n >= i; n--)
		L->Data[n] = L->Data[n - 1];
	++L->length;
	L->Data[i - 1] = x;
	Put(L);
	return 1;
}
int Delete(List L,int i)//删除指定位置的数据
{      int n;
	if (L->length == 0)
	{
	 printf("顺序表为空表，删除失败！\n");
		return -1;
	}
	if (i<1 || i>L->length)
	{
		printf("删除位置非法，删除失败！");
		return 0;
	}
     printf("删除位置i上的数据为 %d \n",L->Data[i - 1] );
	for ( n = i-1; n < L->length - 1; n++)
		L->Data[n] = L->Data[n + 1];
	--L->length;
	return 1;
}
void Empty(List  L)//置空顺序表
{
	L->length = 0;
}
void Union(List A, List B, List C)//求集合A和B的并集，并存放在集合C中
{
	int i =0 , j = 0,k = 0;
	while (i<A->length&&j<B->length)
	{
		if (A->Data[i] <= B->Data[j])
		{
			C->Data[k++] = A->Data[i++];
			j++;
		}
		else
			C->Data[k++] = B->Data[j++];
	}
	while (i < A->length)
		C->Data[k++] = A->Data[i++];
	while (j < B->length)
		C->Data[k++] = B->Data[j++];
	C->length = k;
	Put(C);
}
void Combine(List A, List B, List C)//合并有序顺序表
{
	int i = 0, j = 0, k = 0;
	while (i < A->length && j < B->length)
	{
		if (A->Data[i] < B->Data[j])
			C->Data[k++] = A->Data[i++];
		else if (A->Data[i] > B->Data[j])
			C->Data[k++] = B->Data[j++];
		else
		{
			C->Data[k++] = A->Data[i++];
			C->Data[k++] = B->Data[j++];
		}
	}
	while (i < A->length)
		C->Data[k++] = A->Data[i++];
	while (j < B->length)
		C->Data[k++] = B->Data[j++];
	C->length = k;
	Put(C);
}
void menu()//操作菜单
{
	system("cls");
	printf("\t\t1-顺序表初始化\n");
	printf("\t\t2-输入数据\n");
	printf("\t\t3-返回线性表长度\n");
	printf("\t\t4-插入数据\n");
	printf("\t\t5-删除数据\n");
	printf("\t\t6-获取指定位置的数据\n");
	printf("\t\t7-搜索数据\n");
	printf("\t\t8-输出数据\n");
	printf("\t\t-------------\n");
	printf("\t\t&-集合的并集\n");
	printf("\t\t@-有序表的合并\n");
	printf("\t\t#-终止程序\n");
	printf("请输入你的选择:  ");
}
int main()
{
	char cmd;
	elemtype x, key,data,i; 
	int *p;
	List L,A, B, C;
	system("cls");
	menu();
	while ((cmd = getchar()) != '#')
	{
		switch (cmd)
		{
		case '1': L=InitList();
			printf("\n\n\n\t\t\t");
			break;
		case '2':	
		{
		     printf("请输入数据个数：\n");
			 scanf("%d",&key);
			  printf("请输入数据：\n");
			for (i = 0; i < key; i++)
			{
				scanf("%d",&x);
				GetData(L, x);
			}
		}
			printf("\n\n\n\t\t\t");
			break;
		case '3':  printf("该线性表长度为 %d\n",L->length);
			printf("\n\n\n\t\t\t");
			break;
		case '4': printf("请输入要插入的位置和数据：\n");
		     scanf("%d %d",&key,&x);
			Insert(L,key,x);
			printf("\n\n\n\t\t\t");
			break;
		case '5': printf("请输入要删除数据的位置：\n");
		   scanf("%d",&key);
			Delete(L,key);
			printf("\n\n\n\t\t\t");
			break;
		case '6': printf("请输入位置：\n");
			  scanf("%d",&key);
			FindByP(L,key);		   
			printf("\n\n\n\t\t\t");
			break;
		case '7': printf("请输入要查找的数据：\n");
			 scanf("%d",&data);
			FindBydata(L,data);
			printf("\n\n\n\t\t\t");
			break;
		case '8': Put(L);
			printf("\n\n\n\t\t\t");
			break;
		case '&':
			A=InitList();
			B=InitList();
			C=InitList();
		    printf("请输入顺序表A的长度：\n");
		     scanf("%d",&key);
		    printf("请按照非降序输入要输入到顺序表A的数据：\n");
			for (i = 0; i < key; i++)
			{
				scanf("%d",&x);
				GetData(A,x);
			}
		     printf("请输入顺序表B的长度：\n");
		     scanf("%d",&key);
		  printf("请按照非降序输入要输入到顺序表B的数据：\n");
			for (i = 0; i < key; i++)
			{
			    scanf("%d",&x);
				GetData(B, x);
			}
		printf( "顺序表A和B的并集：\n");
			Union(A,B,C);
			break;
		case '@':
			A=InitList();
			B=InitList();
			C=InitList();
			printf( "请输入顺序表A的长度：\n");
		      scanf("%d",&key);
		printf("请按照非降序输入要输入到顺序表A的数据：\n");
			for (i = 0; i < key; i++)
			{
				scanf("%d",&x);
				GetData(A, x);
			}
		    printf( "请输入顺序表B的长度：\n");
		     scanf("%d",&key);
			printf("请按照非降序输入要输入到顺序表B的数据：\n");
			for (i = 0; i < key; i++)
			{
			    scanf("%d",&x);
				GetData(B, x);
			}
			Combine(A,B,C);
			break;
		}
		fflush(stdin);
		system("pause");
		menu();
	}
	return 0;
}
```

# 1）链表的操作，找不到了（第一次用stl做的）

```cpp
#include <stdio.h>
#include <stdlib.h>
#include <iostream.h>

//结构体的定义
typedef int elemtype;
typedef struct node
{
    elemtype data;
    struct node * next;
} LinkList;
LinkList *head;
 
//用头插法创建单链表
LinkList *Create_LinkListF()
{
    elemtype ix;
    LinkList *head, *p;
    head = (LinkList *) malloc(sizeof(LinkList));
    if(head == NULL)
    {
        return head;
    }
    head -> next = NULL;
    printf("请输入数据直到输入0结束：\n");
    scanf("%d",&ix);
    while(ix != 0)
    {
        p = (LinkList *)malloc(sizeof(LinkList));
        if(p == NULL)
        {
            return head;
        }
        p -> data = ix;
        p -> next = head -> next;
        head -> next = p;
        scanf("%d",&ix);
    }
    return head;
}
 
//查找某序号的结点
LinkList *GetData_LinkList(LinkList *head, int i)
{
    LinkList *p;
    int j = 0;
    if(i <= 0)
    {
        return NULL;
    }
    p = head;
    while(p -> next != NULL && j < i)
    {
        p = p -> next;
        j++;
    }
    if(i == j)
    {
        return p;
    }
    else return NULL;
}
 
//后插
void InsertAfter_LinkList(LinkList *p, LinkList *s)
{
    s -> next = p -> next;
    p -> next = s;
}
 
//删除结点的后继节点
int DeleteAfter_LinkList(LinkList *p)
{
    LinkList *r;
    if(! p)
    {
        return 0;
    }
    r = p -> next;
    if(! r)
    {
        return 0;
    }
    p -> next = r -> next;
    free(r);
    return 1;
}
 
//遍历
int Print_LinkList(LinkList *head)
{
    LinkList *p = head -> next;
    if(p == NULL)
    {
        return 0;
    }
    while(p != NULL)
    {
        printf("%d\t", p -> data);
        p = p -> next;
    }
    printf("\n");
    return 1;
}
 
int main()
{
    int *List_head;
    int *Insert_head;
    int newData;
    int deleteNode;
    int find;
    int chose = -1;
    List_head = Create_LinkListF();
    LinkList *Insert_List;
    Insert_List = (LinkList *)malloc(sizeof(LinkList));
    printf("以下是链表中的元素\n");
    Print_LinkList(List_head);
    printf("1.查找某序号的结点\n");
    printf("2.后插\n");
    printf("3.删除结点的后继结点\n");
    printf("4.遍历\n");
    printf("0.退出程序\n");
 
    while(chose != 0)
    {
        printf("输入功能前的数字来选择你想进行的操作\n");
        scanf("%d",&chose);
        switch(chose)
        {
        case 1:
            printf("输入你想查找的序号\n");
            scanf("%d",&find);
            printf("%d\n",GetData_LinkList(List_head, find) -> data);
            break;
        case 2:
            printf("输入你想插入的结点\n");
            scanf("%d",&newData);
            Insert_List -> data = newData;
            InsertAfter_LinkList(List_head, Insert_List);
            printf("以下是链表中的元素\n");
            Print_LinkList(List_head);
            break;
        case 3:
            printf("输入你想删除的结点的后继结点\n");
            scanf("%d",&deleteNode);
            DeleteAfter_LinkList(GetData_LinkList(List_head, deleteNode));
            printf("以下是链表中的元素\n");
            Print_LinkList(List_head);
            break;
        case 4:
            printf("以下是链表中的元素\n");
            Print_LinkList(List_head);
            break;
        case 0:
            printf("程序退出");
            return 0;
        default:
            printf("你输入的功能序号不合法\n");
            break;
        }
    }
    return 0;
}
```



# 2）一元多项式

## https://blog.csdn.net/upc122/article/details/105313738

```cpp
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<algorithm>
using namespace std;
typedef struct node
{
    int coe;
    int exp;
    struct node *next;
}Node;
class poly//多项式(polynomial)
{
private:
    Node *head;
    int len;
public:
    poly();//构造函数，生成头结点
    int getlen();//获得链表长度，有时会很有用
    void input(int tag);//输入多项式
    void Insert(int index,int x1,int x2);//插入结点（此题中在尾部插入）
    void add(poly a,poly b);//加法
    void sub(poly a,poly b);//减法
    void mul(poly a,poly b);//乘法（最难搞）
    void dif(poly a);//求导（注意不要影响到原来的多项式）
    void val(float v);//求值
    void clr();//清空多项式
    void show();//输出多项式
};
poly::poly()//构造函数，生成头结点
{
    head=new Node;
    if(head==NULL)
    {
        printf("memory allocation error!");
        exit(1);
    }
    head->next=NULL;
    len=0;
}
int poly::getlen()//获得链表长度，有时会很有用
{
    return len;
}
void poly::input(int tag)//输入多项式
{
    int a,b;
    Node *p=head;
    scanf("%d",&a);
    scanf("%d",&b);
    while(a!=0)
    {
        Node*t=new Node;
        if(t==NULL)
        {
            printf("memory allocation error!");
            exit(1);
        }
        t->coe=a;
        t->exp=b;
        p->next=t;
        p=t;
        len++;
        scanf("%d",&a);
        if(a==0)break;
        scanf("%d",&b);
    }
    p->next=NULL;
}
void poly::Insert(int index,int x1,int x2)//插入结点（此题中在尾部插入）
{
    if(index>len+1||index<0)
    {
        printf("not insert!");
        exit(1);
    }
    int i=0;
    Node *p=head;
    while(p->next!=NULL&&i<=index-2)
    {
        p=p->next;
        i++;
    }
    Node *t=new Node;
    t->coe=x1;
    t->exp=x2;
    t->next=p->next;
    p->next=t;
    len++;
}
void poly::add(poly a,poly b)//加法
{
	if(a.getlen()==0||b.getlen()==0)
    {
        printf("error!\n");
        return;
    }
    Node *t1,*t2;
    int k=0;
    t1=a.head->next;
    t2=b.head->next;
    while(t1!=NULL&&t2!=NULL)
    {
        if(t1->exp<t2->exp)
        {
            Insert(++k,t1->coe,t1->exp);
            t1=t1->next;
        }
        else if(t1->exp>t2->exp)
        {
            Insert(++k,t2->coe,t2->exp);
            t2=t2->next;
        }
        else
        {
            if(t1->coe+t2->coe!=0)Insert(++k,t1->coe+t2->coe,t2->exp);
            t1=t1->next;
            t2=t2->next;
        }
    }
    while(t1!=NULL)
    {
        Insert(++k,t1->coe,t1->exp);
        t1=t1->next;
    }
    while(t2!=NULL)
    {
        Insert(++k,t2->coe,t2->exp);
        t2=t2->next;
    }
}
void poly::sub(poly a,poly b)//减法
{
	if(a.getlen()==0||b.getlen()==0)
    {
        printf("error!\n");
        return;
    }
    Node *t1,*t2;
    int k=0;
    t1=a.head->next;
    t2=b.head->next;
    while(t1!=NULL&&t2!=NULL)
    {
        if(t1->exp<t2->exp)
        {
            Insert(++k,t1->coe,t1->exp);
            t1=t1->next;
        }
        else if(t1->exp>t2->exp)
        {
            Insert(++k,-t2->coe,t2->exp);
            t2=t2->next;
        }
        else
        {
            if(t1->coe-t2->coe!=0)Insert(++k,t1->coe-t2->coe,t2->exp);
            t1=t1->next;
            t2=t2->next;
        }
    }
    while(t1!=NULL)
    {
        Insert(++k,t1->coe,t1->exp);
        t1=t1->next;
    }
    while(t2!=NULL)
    {
        Insert(++k,-t2->coe,t2->exp);
        t2=t2->next;
    }
}
void poly::mul(poly a,poly b)//乘法（最难搞）
{
	if(a.getlen()==0||b.getlen()==0)
    {
        printf("error!\n");
        return;
    }
    Node*t1,*t2,*t3;
    t1=a.head->next;
    t2=b.head->next;
    int k=0,x,y;
    while(t2!=NULL)
    {
        Insert(++k,t1->coe*t2->coe,t1->exp+t2->exp);
        t2=t2->next;
    }
    t1=t1->next;
    while(t1!=NULL)
    {
        t2=b.head->next;
        t3=head->next;
        while(t2!=NULL)
        {
            x=t1->coe*t2->coe;
            y=t1->exp+t2->exp;
            while(t3->next!=NULL&&t3->exp<y)
            {
                if(t3->next->exp<=y)t3=t3->next;
                else break;
            }
            if(t3->next==NULL)Insert(++k,x,y);
            else
            {
                if(t3->exp==y)
                {
                    if(t3->coe+x!=0)t3->coe+=x;
                    else
                    {
                        Node *t=new Node;
                        t=t3->next;
                        t3->next=t->next;
                        delete t;
                    }
                }
                else if(t3->exp<y)
                {
                    Node *temp=new Node;
                    temp->coe=x;
                    temp->exp=y;
                    temp->next=t3->next;
                    t3->next=temp;
                    t3=t3->next;
                }
            }
            t2=t2->next;
        }
        t1=t1->next;
    }
    t1=head;
    while(t1->next!=NULL)
    {
        t2=t1->next;
        while(t2->next!=NULL)
        {
            if(t1->next->exp==t2->next->exp)
            {
                if(t1->next->coe+t2->next->coe==0)
                {
                    Node *t,*t0;
                    t=t1->next;
                    t1->next=t->next;
                    delete t;
                    len--;
                    t0=t2->next;
                    t2->next=t0->next;
                    delete t0;
                    len--;
                }
                else
                {
                    t1->next->coe+=t2->next->coe;
                    Node*t;
                    t=t2->next;
                    t2->next=t->next;
                    delete t;
                    len--;
                }
            }
            t2=t2->next;
        }
        t1=t1->next;
    }
}
void poly::dif(poly a)//求导（注意不要影响到原来的多项式）
{
	if(a.getlen()==0)
    {
        printf("error!\n");
        return;
    }
    Node *t;
    int k=0;
    t=a.head;
    while(t->next!=NULL)
    {
        if(t->next->exp!=0)Insert(++k,t->next->coe*t->next->exp,t->next->exp-1);
        t=t->next;
    }
    t->next=NULL;
}
void poly::val(float v)//求值
{
    float sum=0;
    Node*t5;
    t5=head->next;
    while(t5!=NULL)
    {
        sum+=t5->coe*pow(v,t5->exp);
        t5=t5->next;
    }
    printf("%.2f\n",sum);
}
void poly::clr()//清空多项式
{
    Node *t;
    while(head->next!=NULL)
    {
        t=head->next;
        head->next=t->next;
        delete t;
        len--;
    }
}
void poly::show()//输出多项式
{
    Node*t;
    int k=1;
    t=head->next;
    printf("C(x)=");
    while(t!=NULL&&k<=len)
    {
        if(t->coe==-1)printf("-");
        else if(t->coe!=1)
        {
            if(t->coe>0&&t!=head->next)printf("+");
            if(t->coe!=0)printf("%d",t->coe);
        }
        if(t->exp!=0)
        {
            printf("x");
            if(t->exp!=1)printf("^%d",t->exp);
        }
        t=t->next;
        k++;
    }
    printf("\n");
}
int main()
{
    char op[5];
    float v;
    poly a,b,cadd,csub,cmul,cdiff;
    while(true)
    {
        scanf("%s",op);
        if(op[0]=='C')
        {
            if(a.getlen()==0)
            {
                a.input(0);
            }
            else a.clr();
            if(b.getlen()==0)
            {
                b.input(0);
            }
            else b.clr();
            if(cadd.getlen()!=0)cadd.clr();
            if(csub.getlen()!=0)csub.clr();
            if(cmul.getlen()!=0)cmul.clr();
            if(cdiff.getlen()!=0)cdiff.clr();
        }
        else if(op[0]=='S')
        {
            csub.sub(a,b);
            csub.show();
        }
        else if(op[0]=='P')
        {
            cadd.add(a,b);
            cadd.show();
        }
        else if(op[0]=='M')
        {
            cmul.mul(a,b);
            cmul.show();
        }
        else if(op[0]=='D')
        {
            cdiff.dif(a);
            cdiff.show();
        }
        else if(op[0]=='V')
        {
            scanf("%f",&v);
            a.val(v);
        }
        else if(op[0]=='X')exit(0);
    }
    return 0;
}

```

# 3）括号比配

## https://blog.csdn.net/qq_42043984/article/details/93100730

```c++
#include<iostream>
#include<stack>
#include<string>
 
using namespace std;
int cnt=0;
char a[1000];
bool flag=false;
 
class SeqStack{
public :
    int *a;
    int top;
public:
    SeqStack()
    {
        a=new int[105];
        top=-1;
    }
    void Push(int x)
    {
        a[++top]=x;
    }
    void Pop()
    {
        top--;
    }
    bool Empty()
    {
        if(top==-1) return true;
        return false;
    }
    int Top()
    {
        return a[top];
    }
};
void Judge(string str)    //使用栈判断括号匹配
{
    //stack <char>s;
    SeqStack s;
    int i=0;
    while(str[i]!='#')
    {
        switch (str[i])
        {
        case '(':
            s.Push('(');
            break;
        case '[':
            s.Push('[');
            break;
        case '<':
            s.Push('<');
            break;
        case '{':
            s.Push('{');
            break;
 
        case ')':
            if(!s.Empty())
            {
                if (s.Top() == '(')
                {
                    s.Pop();
                }
                else
                {
                    a[cnt]=s.Top();
                    cnt++;
 
 
                }
            }
            else
            {
                //s.push(')');
                cout<<"The "<<i+1<<" character"<<" '"<<str[i]<<"' is wrong."<<endl;
                flag=true;
            }
            break;
        case '>':
            if(!s.Empty())
            {
                if (s.Top() == '<')
                {
                    s.Pop();
                }
                else
                {
                    a[cnt]=s.Top();
                    cnt++;
                }
            }
            else
            {
                //s.push('>');
                cout<<"The "<<i+1<<" character"<<" '"<<str[i]<<"' is wrong."<<endl; flag=true;
            }
            break;
        case ']':
            if(!s.Empty())
            {
                if (s.Top() == '[')
                {
                    s.Pop();
                }
                else
                {
                    a[cnt]=s.Top();
                    cnt++;
                }
            }
            else
            {
                //s.push(']');
                cout<<"The "<<i+1<<" character"<<" '"<<str[i]<<"' is wrong."<<endl; flag=true;
            }
            break;
        case '}':
            if(!s.Empty())
            {
                if (s.Top() == '{')
                {
                    s.Pop();
                }
                else
                {
                    a[cnt]=s.Top();
                    cnt++;
                }
            }
            else
            {
                cout<<"The "<<i+1<<" character"<<" '"<<str[i]<<"' is wrong."<<endl;
            }
            break;
        }
        i++;
    }
    if (s.Empty()&& flag==false)
    {
        cout<<"right"<<endl;
    }
    else if(!s.Empty())
    {
        cout<<"loss of right character ";
        while(!s.Empty())
        {
            if(s.Top()=='<') cout<<">";
            if(s.Top()=='(') cout<<")";
            if(s.Top()=='{') cout<<"}";
            if(s.Top()=='[') cout<<"]";
            s.Pop();
        }
        cout<<'.'<<endl;
    }
   if(cnt)
    {
        cout<<"loss of right character ";
        for(int i=0; i<cnt; i++)
        {
            cout<<a[i];
        }
        cout<<endl;
    }
 
}
 
int main()
{
    string str;
    cin >> str;
    Judge(str);
//	system("pause");
    return 0;
 
}
```



# 4）二叉树链式存储：

## https://blog.csdn.net/weixin_46090517/article/details/106189878

```cpp
#include<iostream>
#include<queue>
#include<stack>

using namespace std;

//二叉树节点
struct BinaryTreeNode
{
    char data;
    BinaryTreeNode* leftChild;
    BinaryTreeNode* rightChild;
};
//堆栈节点，用于深度遍历
struct stackNode
{
    BinaryTreeNode* ptr;
    char tag;//tag=0标志进入左子树，tag=1标志进入右子树
};

class BinaryTree //二叉树的类
{
public:
//根据完全前序遍历创建二叉树
    void createBinaryTree(BinaryTreeNode* &root)
    {
        root=new BinaryTreeNode();
        char newData;
        cin>>newData;
        if(newData=='#')
        {
            root=NULL;
        }
        else
        {
            root->data=newData;
            createBinaryTree(root->leftChild);
            createBinaryTree(root->rightChild);
        }
    }
//递归实现前序遍历
    void preTraversal(BinaryTreeNode* root)
    {
        if(root!=NULL)
        {
            cout<<root->data<<" ";
            preTraversal(root->leftChild);
            preTraversal(root->rightChild);
        }
    }

//递归实现后续遍历
    void lastTraversal(BinaryTreeNode* root)
    {
        if(root!=NULL)
        {
            lastTraversal(root->leftChild);
            lastTraversal(root->rightChild);
            cout<<root->data<<" ";
        }
    }

//非递归实现中序遍历
    void mid(BinaryTreeNode* root)
    {
        stack<BinaryTreeNode*> S;
        BinaryTreeNode* p=root;
        do
        {
            while(p!=NULL)
            {
                S.push(p);
                p=p->leftChild;
            }
            if(!S.empty())
            {
                p=S.top();
                cout<<p->data<<" ";
                S.pop();
                p=p->rightChild;
            }
        }
        while(p!=NULL||!S.empty());
    }


//计算节点总数
    int nodeCount(BinaryTreeNode* &root)
    {
        if(root==NULL)
        {
            return 0;
        }
        else
        {
            return nodeCount(root->leftChild)+nodeCount(root->rightChild)+1;
        }
    }
//计算二叉树的高度
    int treeHight(BinaryTreeNode* &root)
    {
        if(root==NULL)
        {
            return 0;
        }
        else
        {
            int LH=treeHight(root->leftChild);
            int RH=treeHight(root->rightChild);
            return LH > RH ? LH+1 : RH+1;
        }
    }
//计算二叉树的叶子个数
    int getLeavesCount(BinaryTreeNode* &root)
    {
        if(root==NULL)
        {
            return 0;
        }
        else if (root->leftChild == NULL && root->rightChild == NULL)
        {
            return 1;
        }
        else
        {
            int leftLeavesCount = getLeavesCount(root->leftChild);
            int rightLeavesCount = getLeavesCount(root->rightChild);
            return leftLeavesCount + rightLeavesCount;
        }
    }
//查找值=x的节点个数
    int findNode(BinaryTreeNode* &root,char x,int coun)
    {

        if(root!=NULL)
        {
            if(root->data==x) coun++;
            findNode(root->leftChild,x,coun);
            findNode(root->rightChild,x,coun);
        }
        return coun;
    }
//以缩格文本形式输出所有节点
    void outputNode(BinaryTreeNode* &root,int x)
    {
        if(root!=NULL)
        {
            for(int i=0;i<x;i++) cout<<" ";
            cout<<root->data<<endl;
            x=x+2;
            outputNode(root->leftChild,x);
            outputNode(root->rightChild,x);
        }

    }

};



int main()
{
    BinaryTree tree;
    BinaryTreeNode* treeRoot;
    char func;
    while(cin>>func){
        if(func=='C')
        {
            tree.createBinaryTree(treeRoot);
            cout<<"Created success!";
        }
        if(func=='1') {cout<<"Preorder is:";tree.preTraversal(treeRoot);cout<<".";}
        if(func=='2') {cout<<"Inorder is:";tree.mid(treeRoot);cout<<".";}
        if(func=='3') {cout<<"Postorder is:";tree.lastTraversal(treeRoot);cout<<".";}
        if(func=='N') cout<<"Nodes="<<tree.nodeCount(treeRoot)<<".";
        if(func=='H') cout<<"Height="<<tree.treeHight(treeRoot)<<".";
        if(func=='L') cout<<"Leaf="<<tree.getLeavesCount(treeRoot)<<".";
        if(func=='F')
        {
            char x;
            cin>>x;
            cout<<"The count of "<<x<<" is "<<tree.findNode(treeRoot,x,0)<<".";
        }
        if(func=='P')
        {
            cout<<"The tree is:"<<endl;
            tree.outputNode(treeRoot,0);
        }
        cout<<endl;
    }

    return 0;
}


```



# 5)图的简单应用：

## https://blog.csdn.net/qq_42043984/article/details/90740169

```c++
#include <iostream>
#include <stdlib.h>
using namespace std;
const int DefaultVertices=100;
const int maxWeight=1000;
typedef int E;
typedef char T;
class Graphmtx{
private:
    T *VerticesList;
    E **Edge;
    int numVertices;
    int maxVertices;
    int numEdge;
public:
    Graphmtx(int sz=DefaultVertices);
    ~Graphmtx(){
        delete []VerticesList;
        delete []Edge;
    }
    T getValue(int i){
        if(i>=0&&i<numVertices){
            return VerticesList[i];
        }
        else{
            cout<<"error"<<endl;
            exit(1);
        }
    }
    int getNumVertices(){
        return numVertices;
    }
    int getVertexPos(T vertex){
        for(int i=0;i<numVertices;i++){
            if(VerticesList[i]==vertex)
                return i;
        }
        return -1;
    }
    E getWeight(int v1,int v2){
        return (v1>-1&&v2>-1)?Edge[v1][v2]:0;
    }
    int getFirstNeighbor(int v);
    int getNextNeighbor(int v,int w);
    bool insertVertex(const T vertex);
    bool removeVertex(int v);
    bool insertEdge(int v1,int v2,E cost);
    bool removeEdge(int v1,int v2);
    void show();
};
Graphmtx::Graphmtx(int sz){
    maxVertices=sz;
    numVertices=0;
    numEdge=0;
    int i,j;
    VerticesList=new T[maxVertices];
    Edge=new E*[maxVertices];
    for(i=0;i<maxVertices;i++){
        Edge[i]=new E[maxVertices];
    }
    for(i=0;i<maxVertices;i++){
        for(j=0;j<maxVertices;j++){
            Edge[i][j]=((i==j)?0:maxWeight);
        }
    }
}
int Graphmtx::getFirstNeighbor(int v){
    if(v>-1){
        for(int col=0;col<numVertices;col++){
            if(Edge[v][col]&&Edge[v][col]<maxWeight)
                return col;
        }
    }
    return -1;
}
int Graphmtx::getNextNeighbor(int v,int w){
    if(v>-1&&w>-1){
        for(int col=w+1;col<numVertices;col++)
            if(Edge[v][col]&&Edge[v][col]<maxWeight)
                return col;
    }
    return -1;
}
bool Graphmtx::insertVertex(const T vertex){
    if(numVertices==maxVertices)
        return false;
    VerticesList[numVertices++]=vertex;
    return true;
}
bool Graphmtx::removeVertex(int v){
    if(v<0||v>=numVertices){
        cout<<"error"<<endl;
        return false;
    }
    if(numVertices==1)
        return false;
    int i,j;
    VerticesList[v]=VerticesList[numVertices-1];
    for(i=0;i<numVertices;i++){
        Edge[i][v]=Edge[i][numVertices-1];
    }
    numVertices--;
    for(j=0;i<numVertices;j++)
        Edge[v][i]=Edge[numVertices][j];
    return true;
}
bool Graphmtx::insertEdge(int v1,int v2,E cost){
    if(v1<0||v1>=numVertices||v2<0||v2>=numVertices){
        cout<<"error"<<endl;
        return false;
    }
    Edge[v1][v2]=cost;
    Edge[v2][v1]=cost;
    return true;
}
bool Graphmtx::removeEdge(int v1,int v2){
    if(v1<0||v1>=numVertices||v2<0||v2>=numVertices){
        cout<<"error"<<endl;
        return false;
    }
    Edge[v1][v2]=maxWeight;
    Edge[v2][v1]=maxWeight;
    numEdge--;
    return true;
}
void Graphmtx::show(){
    for(int i=0;i<numVertices;i++){
        for(int j=i;j<numVertices;j++){
            if(Edge[i][j]>0&&Edge[i][j]<maxWeight)
                cout<<VerticesList[i]<<"-"<<VerticesList[j]<<":"<<Edge[i][j]<<endl;
        }
    }
    cout<<endl;
}
class SeqQueue {
protected:
     int rear, fron;
     int*elements;
     int maxSize;
public:
    SeqQueue(int sz = 20){
        fron=0; rear=0; maxSize=sz;
        elements = new int[maxSize];
    }
    int push(int x){
        elements[rear] = x;
        rear = (rear+1) % maxSize;
        return 1;
    }
    int pop(int& x){
        if (IsEmpty()) return 0;
        x = elements[fron];
        fron = (fron+1) % maxSize;
        return 1;
    }
    int IsEmpty() const { return fron == rear;}
};
void DFS (Graphmtx& G, int v, bool *visited) {
    cout << G.getValue(v) << ' ';
    visited[v] = true;
    int w = G.getFirstNeighbor (v);
    while (w != -1) {
      if ( !visited[w] ) DFS(G, w, visited);
     w = G.getNextNeighbor (v, w);
    }
}
void DFS (Graphmtx& G, const T& v) {
    int i, loc, n = G.getNumVertices();
    bool *visited = new bool[n];
    for (i = 0; i < n; i++) visited [i] = false;
 loc = G.getVertexPos(v);
    DFS(G,loc,visited);
    delete [] visited;
}
void BFS (Graphmtx& G, const T& v) {
    int i, w, n = G.getNumVertices();
    bool *visited = new bool[n];
    for (i = 0; i < n; i++) visited[i] = false;
    int loc = G.getVertexPos (v);
    cout<<G.getValue(loc)<<' ';
    visited[loc]=true;
    SeqQueue Q;Q.push (loc);
    while (!Q.IsEmpty() ) {
    Q.pop (loc);
    w = G.getFirstNeighbor (loc);
            while (w != -1) {
                if (visited[w]==false){
                    cout<<G.getValue(w)<<' ';
                    visited[w]=true;
                    Q.push (w);
                }
                w = G.getNextNeighbor (loc, w);
             }
      }
      delete [] visited;
}


int main(){
    Graphmtx g;
    int n1,n2;
    cin>>n1;
    char ch;
    cin>>ch;
    g.insertVertex(ch);
    for(int i=1;i<n1;i++){
        char ch;
        cin>>ch;
        g.insertVertex(ch);
    }
    cin>>n2;
    for(int i=0;i<n2;i++){
        int v1,v2,cost;
        cin>>v1>>v2>>cost;
        g.insertEdge(v1,v2,cost);
    }
    cout<<"DFS:";
    DFS(g,ch);
    cout<<endl;
    cout<<"BFS:";
    BFS(g,ch);cout<<endl;
    cout<<"edges are:"<<endl;
    g.show();
    return 0;
}
```

## 二叉排序树

```c++
SearchBST (K, &t) {
	//K 为待查关键字，t 为根结点指针
	p=t;
	//p 为查找过程中进行扫描的指针
	while（p!=NULL） {
		case {
			//查找成功，
			K= p->data: {
				return;
			}
            //继续向左搜索
			K< p->data : {
				q=p；p=p->L_child;
			}
			//继续向右搜索
			K> p->data : {
				q=p；p=p->R_child;
			}
		}
	}
	//查找不成功则插入到二叉排序树中
	s =(BiTree)malloc(sizeof(BiTNode));
	s ->data=K;
	s ->L_child=NULL;
	s ->R_child=NULL;
	//查找不成功，生成一个新结点 s，插入到二叉排序树叶子处
	case {
		t=NULL： t=s;
		//若 t 为空，则插入的结点 s 作为根结点
		K < q->data: q->L_child=s;
		//若 K 比叶子小，挂左边
		K > q->data: q->R_child=s;
		//若 K 比叶子大，挂右边
	}
	return OK
}
```

## 朴素插入排序

```c++
void InsertSort ( SqList &L ) {
	//对顺序表 L 作直接插入排序
	for ( i = 2; i <=L.length; i++) //假定第一个记录有序 {
		L.r[0]= L.r[i];
		j=i-1 ;
		//先将待插入的元素放入“哨兵”位置
		while（L[0] .key<L[j].key) {
			L.r[j+1]= L.r[j];
			j-- ;
		}
		//只要子表元素比哨兵大就不断后移
		L.r[j+1]= L.r[0];
		//直到子表元素小于哨兵，将哨兵值送入
		//当前要插入的位置（包括插入到表首）
	}
}
```

