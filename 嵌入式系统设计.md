# 嵌入式系统设计

## Linux 系统启动过程

这是嵌入式 Linux 系统启动过程中的不同组成部分：

1. **Bootloader（引导加载程序）**:
   - **定义**：引导加载程序是系统启动时运行的第一段软件，负责引导操作系统的加载。在嵌入式系统中，常见的引导加载程序包括 U-Boot 和 Das U-Boot。
   - **作用**：引导加载程序初始化硬件，加载内核镜像到内存中，然后将控制权传递给加载的内核。
2. **Embedded Linux Kernel（嵌入式 Linux 内核）**:
   - **定义**：内核是操作系统的核心，负责管理硬件、内存、文件系统以及提供系统调用等基本功能。在嵌入式系统中，通常使用精简的 Linux 内核。
   - **作用**：内核负责启动系统并提供运行用户空间应用程序所需的服务。
3. **Device Driver（设备驱动程序）**:
   - **定义**：设备驱动程序是内核模块，用于控制硬件设备。它们与内核协同工作，使得用户空间应用程序可以通过标准接口与硬件进行通信。
   - **作用**：设备驱动程序允许内核与硬件设备进行交互，提供统一的接口供上层软件使用。
4. **Root Filesystem（根文件系统）**:
   - **定义**：根文件系统是整个文件系统层次结构的顶级，包含操作系统的核心文件和目录。在嵌入式系统中，通常是一个轻量级的文件系统，例如 BusyBox。
   - **作用**：根文件系统提供了运行时所需的文件、工具和库，以及必要的配置文件。
5. **Application（应用程序）**:
   - **定义**：应用程序是用户在嵌入式系统中运行的软件。这可以是任何定制的应用，从命令行实用工具到图形用户界面（GUI）应用。
   - **作用**：应用程序通过操作系统提供的接口与硬件和其他软件组件进行交互，实现系统的特定功能。

这些组件一起协同工作，构成了嵌入式 Linux 系统的基本结构。在启动时，引导加载程序负责初始化硬件并加载内核，然后内核负责初始化设备驱动程序、根文件系统等，最终启动用户空间应用程序。

## **Linux 下设备驱动的特点：**

- Linux下的设备控制由驱动程序完成
  - Linux下对外设的访问只能通过驱动程序
  - Linux对于驱动程序有统一的接口，以文件的形式定义系统的驱动程序
    - Open、Release、read、write、ioctl
  - 驱动程序属于内核的一部分，可以使用中断、DMA等操作
  - 驱动程序需要在用户态和内核态之间传递数据，是应用程序与内核及外设通讯的桥梁

## Linux驱动开发调试的两种方法

-  一种是直接编译到内核，再运行新的内核来测试 **（效率低）**
- 二是编译为模块的形式，单独加载运行调试 (insmod将编译的模块直接插入内核，rmmod从内核中卸载模块，**不需要重新启动内核，效率高**)

## 驱动程序与应用程序的区别

- **应用程序**一般有一个**main函数**，从头到尾执行一个任务
- 驱动程序没有main函数，通过使用**宏module_init**（初始化函数名）
- 将初始化函数加入内核全局初始化函数列表中，在内核初始化时执行驱动的初始化函数，从而完成驱动的初始化和注册，之后驱动便停止等待被应用软件调用
- 应用程序可以和**GLIBC库** `glibc（GNU C Library） 是一个用于 Linux 系统的C标准库。`连接，因此可以包含标准的头文件，比如`<stdio.h> <stdlib.h>`
- **驱动程序不能使用标准C库**，因此不能调用所有的C库函数，比如输出打印函数只能用内核的printk函数，包含的头文件只能是内核的头文件，比如`<linux/module.h>`
- 当模块与内核链接时，**insmod**（insert module)会检查模块和当前内核版本是否匹配，每个模块都定义了版本符号`__module_kernel_version`，只要在模块中包含`<linux/module.h>`，编译器就会自动定义此符号
- 每个内核版本都需要**特定版本的编译器**的支持，高版本的编译器并不适合低版本的内核
- 传统方式中的设备管理中，除了设备类型外，内核还需要一对称作主次设备号的参数，才能唯一标识一个设备。主设备号相同的设备使用相同的驱动程序，次设备号用于区分具体设备的实例。
- 在Linux内核中有许多设备号已经静态的赋予一些常用设备，剩余给我们的设备号已经不多。如果我们的设备



# GCC & GDB

gcc 与 g++ 分别是 gnu 的 c & c++ 编译器 gcc/g++ 在执行编译工作的时候，总共需要4步：

- 1、预处理,生成 .i 的文件[**预处理器cpp**]
- 2、将预处理后的文件转换成汇编语言, 生成文件 .s [**编译器egcs**]
- 3、有汇编变为目标代码(机器代码)生成 .o 的文件[**汇编器as**]
- 4、连接目标代码, 生成可执行程序 [**链接器ld**]

## 1、设定文件所使用的语言 -x

可以编译不是指定文件后缀的文件，.c .cpp

```bash
gcc -x language filename
```

```bash
gcc -x none filename
```

## 2、只把程序做成obj文件 -c

```bash
gcc -c hello.c
```

## 3、只激活预处理和编译，编译为汇编代码 -S

```bash
gcc -S hello.c
```

## 4、只激活预处理，不生成文件

# ARM

1. **用户模式（usr）**：
   - 正常的程序执行模式，用于大多数应用程序的运行。
2. **快速中断模式（fiq）**：
   - 用于支持高速数据传输或通道处理，提供更快的中断响应。
3. **外部中断模式（irq）**：
   - 用于通用的中断处理，提供一般性的中断服务。
4. **管理模式（svc）**：
   - 是操作系统的保护模式，用于执行特权指令，提供操作系统的服务。
5. **数据访问终止模式（abt）**：
   - 当数据或指令预取终止时，进入该模式。通常用于虚拟存储和存储保护。
6. **系统模式（sys）**：
   - 支持操作系统的特殊用户模式，用于运行操作系统任务。
7. **未定义模式（und）**：
   - 用于支持硬件协处理器的软件仿真，处理未定义的指令。

# GCC & Makefile





# 驱动





# 网络

