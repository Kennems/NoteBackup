# 发布便捷编辑

# --------

# Go 语言基础语法和常用特性实践

## Go基础语言

### 什么是Go语言？

Go语言是一种开源编程语言，由Google开发。它具有以下特点：

1. **简洁易学**：Go语言的语法简洁、清晰，易于学习和理解，减少了代码的复杂性。
2. **高性能**：Go语言采用了垃圾回收机制，可以自动管理内存，提高了程序执行效率。同时，Go语言通过并行计算和协程（goroutine）的概念，支持高并发操作。
3. **静态类型**：Go语言是一种静态类型的编程语言，可以在编译时检查代码的类型安全性，减少了运行时错误。
4. **跨平台**：Go语言的编译器可以将Go代码编译为机器码，从而可以在不同的操作系统和硬件平台上运行。
5. **丰富的标准库**：Go语言拥有丰富的标准库，包含了各种功能模块，例如网络、文件操作、并发等，开发者可以直接使用这些库来加速开发。
6. **开发效率高**：Go语言具有良好的工具链，包括代码格式化工具、自动化构建工具等，可以提高开发效率。

#### 1）搭建开发环境

1）安装Golang：下载并安装Go语言的最新版本。

2）选择一个适合的开发环境，例如`Visual Studio Code``（VSCode）`或者`Goland`，也可以使用云开发环境如`Gitpod`。

#### 2）基础语法

##### 2.1 Hello World

```go
package main // 声明主程序包
import ( // 导入所需的包
	"fmt"
)
func main() { // 声明主函数
	fmt.Println("Hello World") // 输出Hello World
}
```

其中`fmt`是一个标准库包，全称为"format"，它提供了格式化输入和输出的功能。

`fmt`包中的函数有：

- 打印输出：`Print`、`Printf`、`Println`等。
- 格式化字符串：`Sprintf`、`Fprintf`等。
- 读取输入：`Scan`、`Scanf`、`Scanln`等。

##### 2.2 变量

Go语言是一门强类型语言，每个变量都有自己的变量类型。常见的变量类型有字符串型、整数型、浮点型和布尔型，类似于C++。

```go
var a = "initial" 	// 声明变量并赋初值
var b, c int = 1, 2 // 声明多个变量并赋值
var d = true 		// 声明变量并赋值
var e float64 		// 声明变量，未赋值
f := float32(e) 	// 使用短变量声明方式赋值，可以自动推导变量类型
g := a + "foo" 		// 可以进行字符串的拼接操作
```

##### 2.3 选择、循环语句

在Go语言中，我们可以使用选择语句（if-else和switch）和循环语句（for）来控制程序的流程。

**if-else语句**是用于在不同条件下执行不同代码块的选择结构。

**for循环**是用于重复执行一段代码块的循环结构。有多种形式的for循环可以选择，包括无限循环、条件循环和计数循环。

下面是示例：

```go
if num := 9; num < 0 { // if-else语句
    fmt.Println(num, "is negative") // 输出结果
} else if num < 10 {
    fmt.Println(num, "has 1 digit")
} else {
    fmt.Println(num, "has multiple digits")
}

for { // 无限循环
    fmt.Println("loop") // 输出结果
    break // 跳出循环
}
for j := 7; j < 9; j++ { // for循环
    fmt.Println(j) // 输出结果
}

switch { // switch语句，后面可不加任何变量
case t.Hour() < 12: // 判断时间的小时部分是否小于12
    fmt.Println("It's before noon") // 输出结果
default:
    fmt.Println("It's after noon")
}
```

在这段示例代码中，展示了在Go语言中使用选择语句（if-else和switch）和循环语句（for）的用法。

首先是if-else语句，通过判断条件是否满足来执行不同的代码块。在示例中，使用if-else语句判断了一个变量num的值，并根据不同的情况打印输出不同的结果。

其次是for循环，用于重复执行一段代码块。示例中展示了两种常见的for循环形式。第一个是无限循环，可以使用for关键字后跟空的条件表达式来创建一个无限循环，在循环体内部使用break语句来跳出循环。第二个是条件循环，使用for关键字后跟条件表达式作为循环的终止条件，然后使用++运算符对循环变量进行递增操作。循环体内部输出了循环变量的值。

最后是switch语句，用于基于不同的情况执行不同的代码块。示例中使用了switch语句来判断当前时间的小时部分是否小于12，如果满足条件，就输出"It's before noon"，否则输出"It's after noon"。

##### 2.4 数组、切片、映射和范围遍历

Go语言中的数组、切片、映射和范围遍历类似于Python语言。

```go
var a [5]int // 声明一个一维数组
a[4] = 100 // 给数组的第五个元素赋值为100
fmt.Println(a[4], len(a)) // 输出数组的第五个元素和数组的长度

var twoD [2][3]int // 声明一个二维数组
for i := 0; i < 2; i++ {
    for j := 0; j < 3; j++ {
        twoD[i][j] = i + j // 对数组的每个元素赋值为行索引加列索引的和
    }
}

s := make([]string, 3) // 声明一个长度为3的切片
s[0] = "a" // 给切片的第一个元素赋值为 "a"
s[1] = "b" // 给切片的第二个元素赋值为 "b"
s[2] = "c" // 给切片的第三个元素赋值为 "c"
fmt.Println(s[2:5]) // 输出切片从索引2到索引4的元素（不包括索引5）
fmt.Println(s[:5]) // 输出切片从索引0到索引4的元素
fmt.Println(s[2:]) // 输出切片从索引2到末尾的所有元素

m := make(map[string]int) // 声明一个映射，键类型为字符串，值类型为整数
m["one"] = 1 // 向映射中添加键值对 "one": 1
m["two"] = 2 // 向映射中添加键值对 "two": 2
fmt.Println(m) // 输出整个映射

nums := []int{2, 3, 4} // 声明一个切片并初始化
sum := 0

for i, num := range nums { // 使用范围遍历切片，i为索引，num为值
    sum += num
    if num == 2 {
        fmt.Println("index", i, "num", num) // 输出值为2的元素的索引和值
    }
}
fmt.Println(sum) // 输出切片中所有元素的和
```

上述示例展示了Go语言中数组、切片、映射和范围遍历的用法。

- 数组是一组具有相同类型的元素的集合，其长度是固定的。可以通过索引访问数组中的元素。
- 切片是一个动态大小的容器，可以根据需要增加或减少大小。切片由指向底层数组的指针、长度和容量组成。
- 映射是无序的键值对集合，通过键来访问值。键必须是唯一的，而值可以重复。
- 范围遍历是一种方便的遍历切片、数组、字符串、映射等集合类型的方法。在每次迭代中，使用两个变量分别表示索引和值。

请注意，数组和切片的索引从0开始，长度等于元素的个数。切片可以使用切片表达式进行截取，以获取子切片。

##### 2.5 函数

```go
func exists(m map[string]string, k string) (v string, ok bool) {
	// 通过键k在map m中查找对应的值v和是否存在的布尔值ok
	v, ok = m[k]
	// 返回值v和ok
	return v, ok
}
```

这里的函数接受两个参数：一个是类型为`map[string]string`的变量`m`，另一个是类型为`string`的变量`k`。返回值有两个：一个是类型为`string`的变量`v`，用来存储键对应的值；另一个是类型为`bool`的变量`ok`，用来表示键是否存在。

在函数内部，使用`m[k]`来查找给定键`k`在`map`中对应的值。如果找到了值，将其赋给`v`并将`ok`设为`true`，表示键存在。如果未能找到值，则`v`将为空字符串且`ok`设为`false`，表示键不存在。

最后，通过`return`语句返回`v`和`ok`。

该函数可以用于判断某个键是否存在于给定的`map`中，并获取其对应的值。可以根据实际需求进行调用和使用。

##### 2.6 指针

```go
// add2ptr 函数用于将指定的整数指针加上2。
func add2ptr(n *int) {
	// 将指针所指向的整数值加上2
	*n += 2
}
```

这段代码定义了一个函数`add2ptr`，它接受一个`*int`类型的指针参数`n`。函数的作用是将`n`指针所指向的变量的值加上2。

在函数内部，通过在变量前面加上`*`来访问指针所指向的变量，然后对其进行修改。

##### 2.7 结构体与结构方法

```go
// user 结构体表示用户信息。
type user struct {
	name     string
	password string
}

// resetPassword 方法用于重置用户的密码。
// - password: 新的密码字符串
func (u *user) resetPassword(password string) {
	// 将用户的密码字段更新为新的密码
	u.password = password
}
```

这段代码定义了一个名为`user`的结构体，它有两个字段：`name`和`password`，类型都是`string`。

接下来定义了一个结构方法`resetPassword`，它接收一个指向`user`类型的指针作为接收者，同时还接收一个`password`参数。

该结构方法的作用是将`user`类型的指针所指向的对象的`password`字段设置为传入的`password`值。

##### 2.8 错误处理

在Go语言中，通常使用单独的返回值来传递错误信息。利用简单的 `if-else` 语句进行错误处理。

```go
func findUser(users []user, name string) (v *user, err error) {
	// 遍历用户列表
	for _, u := range users {
		// 如果用户名匹配，则返回该用户的指针和nil错误
		if u.name == name {
			return &u, nil
		}
	}
	// 如果未找到匹配的用户，则返回nil指针和自定义的错误信息
	return nil, errors.New("not found")
}
// 创建一个包含单个用户的用户列表，并查找指定用户名的用户
u, err := findUser([]user{{"wang", "1024"}}, "wang")
if err != nil {
	// 如果发生错误，打印错误信息并返回
	fmt.Println(err)
	return
}
// 打印找到的用户的用户名
fmt.Println(u.name)
```

在这段代码中，首先调用函数`findUser`来查找用户信息。函数接收一个`[]user`类型的切片参数`users`和一个`string`类型的参数`name`。函数返回两个值，第一个是指向`user`类型的指针变量`v`，第二个是`error`类型的变量`err`。

函数内部的逻辑是遍历`users`切片，如果找到与`name`匹配的用户，则返回指向该用户的指针和`nil`错误。如果没有找到匹配的用户，则返回`nil`指针和一个自定义的错误信息。

在调用函数时，使用`:=`语法同时接收函数返回的两个值。然后通过判断`err`是否为`nil`来检查是否发生了错误，并进行相应的处理。

##### 2.9 字符串操作与格式化

Go语言的`strings`包提供了许多方便的字符串处理函数。字符串格式化可以使用类似C语言中的`printf()`函数的方式来格式化字符串。其中，`%v`可以打印任意类型的变量，`%+v`会打印更详细的结果，`%#v`会打印最详细的结果。

```go
a := "hello"
// 判断字符串a是否包含子串"li"
fmt.Println(strings.Contains(a, "li"))
// 计算字符串a中子串"l"出现的次数
fmt.Println(strings.Count(a, "l"))
// 判断字符串a是否以"he"开头
fmt.Println(strings.HasPrefix(a, "he"))
// 判断字符串a是否以"llo"结尾
fmt.Println(strings.HasSuffix(a, "llo"))
// 在字符串a中查找子串"li"的索引位置，不存在则返回-1
fmt.Println(strings.Index(a, "li"))
// 使用连接符将字符串切片{"he", "llo"}连接成一个字符串
fmt.Println(strings.Join([]string{"he", "llo"}, "-"))
// 将字符串a重复2次
fmt.Println(strings.Repeat(a, 2))
// 替换字符串a中的子串"e"为"E"，-1表示全部替换
fmt.Println(strings.Replace(a, "e", "E", -1))
// 将字符串"a-b-c"按照"-"进行分割，并返回字符串切片
fmt.Println(strings.Split("a-b-c", "-"))
// 将字符串a转换为小写
fmt.Println(strings.ToLower(a))
// 将字符串a转换为大写
fmt.Println(strings.ToUpper(a))
// 获取字符串a的长度
fmt.Println(len(a))
s := "string"
n := 10
p := &s
// 格式化输出，%v表示默认格式
fmt.Printf("s=%v\n", s)
// 格式化输出，%v表示默认格式
fmt.Printf("n=%v\n", n)
// 格式化输出指针的值
fmt.Printf("p=%v\n", p)
// 格式化输出指针的值，并包含类型信息
fmt.Printf("p=%+v\n", p)
// 格式化输出指针的值，并包含Go语法表示
fmt.Printf("p=%#v\n", p)
f := 3.141592653
// 打印浮点数f，不指定精度，默认保留小数点后6位
fmt.Println(f)
// 指定浮点数f的精度为2位
fmt.Printf("%.2f\n", f)
```

在这段代码中，通过调用 `strings` 包中的函数，对字符串 `a` 进行了一系列操作，如检查是否包含子串、统计子串出现的次数、判断是否有指定的前缀和后缀、查找子串在字符串中的位置、用指定连接符连接字符串片段、重复字符串、替换子串等。另外，还使用 `%v`、`%+v`、`%#v` 等格式化占位符打印了不同类型的变量，这些函数和格式化占位符在字符串处理和格式化输出方面非常有用，可以根据实际需求来使用它们。

##### 2.10 JSON处理

在Go语言中，如果一个结构体的字段首字母大写，就可以使用 `json.Marshal()` 方法将其序列化为 JSON 字符串，同时也可以使用 `json.Unmarshal()` 方法将 JSON 字符串反序列化为对象。

```go
// 定义 userInfo 结构体
type userInfo struct {
	Name  string   `json:"name"`  // 用户名
	Age   int      `json:"age"`   // 年龄
	Hobby []string `json:"hobby"` // 爱好
}
// 创建 userInfo 对象 a
a := userInfo{Name: "wang", Age: 18, Hobby: []string{"Golang", "TypeScript"}}
// 将 userInfo 对象转换为 JSON 字节切片
buf, err := json.Marshal(a)
if err != nil {
	panic(err)
}
fmt.Println(buf)              // 打印 JSON 字节切片
fmt.Println(string(buf))      // 打印 JSON 字符串
// 使用 json.MarshalIndent 将 userInfo 对象转换为带缩进的 JSON 字符串
buf, err = json.MarshalIndent(a, "", "\t")
if err != nil {
	panic(err)
}
fmt.Println(string(buf))      // 打印带缩进的 JSON 字符串
// 将 JSON 字符串解析成 userInfo 对象 b
var b userInfo
err = json.Unmarshal(buf, &b)
if err != nil {
	panic(err)
}
fmt.Printf("%#v\n", b)        // 打印解析后的 userInfo 对象
```

这段代码演示了在Go语言中如何处理JSON数据。我们定义了一个`userInfo`结构体，其中包含三个字段：`Name`（用户名）、`Age`（年龄）和`Hobby`（爱好）。注意到这些字段的后面都有一个`json`标签，用于指定字段在JSON中的名称。创建了一个`userInfo`对象`a`，并给它的字段赋值。接下来，使用`json.Marshal()`将`a`对象序列化为JSON字节切片，并使用`fmt.Println()`打印结果。`json.Marshal()`函数将对象转换为JSON格式，使其可以在网络传输或存储中使用。

为了更好地展示JSON字符串，我们使用`string()`函数将JSON字节切片转换为字符串，并再次打印结果。

之后我们使用`json.MarshalIndent()`对`a`对象进行格式化的序列化，第二个参数为空字符串表示不添加额外的缩进，第三个参数为制表符`\t`，表示使用制表符缩进。然后，使用`fmt.Println()`打印带缩进的JSON字符串。我们使用`json.Unmarshal()`将JSON字符串反序列化为`userInfo`对象`b`。通过将JSON字符串作为输入，并提供一个指向`b`的指针，`json.Unmarshal()`将JSON数据解析并填充到`b`对象的相应字段中。然后，使用`fmt.Printf()`以更详细的方式打印`b`对象的内容。

这些函数和方法在处理JSON数据时非常有用，可以方便地进行序列化和反序列化操作。

##### 2.11 时间处理与数字解析

在Go语言中，可以使用 `time.Now()` 获取当前时间，也可以使用 `time.Date()` 构造带有时区信息的时间对象。可以使用 `Sub()` 方法计算两个时间点之间的时间差，使用 `Unix()` 方法获取时间戳。

数字解析可以使用 `strconv` 包下的函数，将字符串转换为数字。

```go
now := time.Now()
fmt.Println(now) // 打印当前时间

t := time.Date(2022, 3, 27, 1, 25, 36, 0, time.UTC)
t1 := time.Date(2022, 3, 27, 2, 30, 36, 0, time.UTC)
fmt.Println(t) // 打印指定时间 t
fmt.Println(t.Year(), t.Month(), t, t.Day(), t.Hour(), t.Minute()) // 打印 t 的年月日时分
fmt.Println(t.Format("2006-01-02 15:04:05")) // 格式化打印 t
diff := t1.Sub(t) // 计算两个时间之间的差值
fmt.Println(diff) // 打印差值
fmt.Println(diff.Minutes(), diff.Seconds()) // 打印差值的分钟数和秒数
t3, err := time.Parse("2006-01-02 15:04:05", "2022-03-27 01:25:36") // 解析时间字符串为时间对象
if err != nil {
    panic(err)
}
fmt.Println(t3 == t) // 判断解析后的时间对象是否等于 t
fmt.Println(now.Unix()) // 获取当前时间的 Unix 时间戳
f, _ := strconv.ParseFloat("1.234", 64) // 将字符串转换为浮点数
fmt.Println(f)
n, _ := strconv.ParseInt("111", 10, 64) // 将字符串转换为整数
fmt.Println(n)
n, _ = strconv.ParseInt("0x1000", 0, 64) // 支持十六进制字符串转换为整数
fmt.Println(n)
n2, _ := strconv.Atoi("123") // 将字符串转换为整数（常用于字符串表示的十进制数）
fmt.Println(n2)
```

这段代码演示了在Go语言中处理时间和数字解析的方法。通过调用`time.Now()`函数获取当前时间，并使用`fmt.Println()`打印输出结果。使用`time.Date()`函数构造了两个具有指定日期、时间和时区的时间对象`t`和`t1`。你可以传入年、月、日、时、分、秒、纳秒和时区信息来创建一个时间对象。使用`fmt.Println()`打印出`t`对象的各个字段值。使用`t.Format()`将时间对象`t`按照指定的格式（"2006-01-02 15:04:05"）进行格式化，并使用`fmt.Println()`打印结果。计算了`t1`和`t`之间的时间差，并将结果存储在变量`diff`中。使用`fmt.Println()`打印时间差值，以及将时间差转换为分钟数和秒数并打印输出。

使用`time.Parse()`函数将字符串"2022-03-27 01:25:36"按照指定的格式解析为时间对象`t3`，并与时间对象`t`进行比较。注意到解析时间字符串时，格式字符串中的年、月、日、时、分、秒必须和实际的字符串完全匹配，且在格式字符串中使用的占位符必须是固定的，如"2006"表示年份，"01"表示月份等。如果解析失败，会返回一个错误。使用`now.Unix()`获取当前时间的Unix时间戳，并使用`fmt.Println()`打印输出结果。

最后，使用`strconv`包下的函数将字符串"1.234"解析为浮点数并打印输出，将字符串"111"解析为十进制整数并打印输出，将字符串"0x1000"解析为十六进制整数并打印输出，以及使用`strconv.Atoi()`将字符串"123"解析为十进制整数并打印输出。

##### 2.12 进程信息

在Go语言中，可以使用 `os.Args` 获取程序执行时指定的命令行参数。

```go
fmt.Println(os.Args) // 打印命令行参数
fmt.Println(os.Getenv("PATH")) // 获取环境变量 PATH 的值并打印
fmt.Println(os.Setenv("AA", "BB")) // 设置环境变量 AA 的值为 BB，并打印结果（设置环境变量成功返回 nil）
buf, err := exec.Command("grep", "127.0.0.1", "/etc/hosts").Output() // 执行命令 grep，查找 /etc/hosts 文件中包含 "127.0.0.1" 的行
if err != nil {
    panic(err)
}
fmt.Println(string(buf)) // 将执行结果转换为字符串并打印
```

这段代码使用 `os.Args` 获取程序执行时指定的命令行参数，并打印输出。

使用 `os.Getenv()` 获取指定环境变量的值，并打印输出。然后，使用 `os.Setenv()` 设置一个环境变量的值。

使用 `exec.Command()` 创建一个执行外部命令的命令对象，并调用 `Output()` 方法执行该命令并获取输出结果。最后，将输出结果转为字符串并打印输出。

这段代码中执行 `grep` 命令需要依赖于操作系统的支持，且可能会因为安全限制而无法正常执行。

## 总结

通过整理和梳理，完成了本文，作为Go语言的**基础语法**和**常用特性**实践总结。主要内容包括搭建开发环境、Hello World程序、变量声明和赋值、选择和循环语句、数组、切片、映射和范围遍历、函数、指针、结构体与结构方法、错误处理、字符串操作与格式化、JSON处理、时间处理与数字解析以及进程信息的获取等。代码示例中的一些参数和路径可能是虚拟的，请根据实际情况进行调整和使用。同时，在实际开发中，还需注意错误处理、异常情况的处理和安全性等问题。go语言作为一门新语言，集结了众多优秀语言的优势，如果已经熟悉`Java`和`Python`以及`C/C++`、`Javascript`其中一种或多种，对于理解掌握Go语言的语法来说可以很快上手，但不可忽视的是Go语言处理服务端的优势，如今众多大厂已经全面拥向Go语言作为后端语言，掌握Go语言也会越发重要。希望这篇文章可以帮助你再复习一遍Go语言基础知识并提升熟练度。我这里想补充一点，对于语言学习以及之后的项目开发，良好的测试覆盖率和清晰的文档是必不可少的。在实践过程中，我们可以编写各种类型的测试，包括单元测试、集成测试和端到端测试等，来确保代码的质量和正确性。而文档则可以帮助其他开发者了解项目的使用方法、接口说明等，提高协作效率。

# ------------------------

# day14 消息队列

消息队列（Message Queue）是一种常见的异步通信模式，用于在分布式系统中传递消息和解耦应用组件。它通过将消息发送到队列中，并由接收方从队列中获取和处理消息，实现了消息的异步传递和解耦。

消息队列的基本原理是：发送方（生产者）将消息发送到队列，而接收方（消费者）从队列中获取消息进行处理。消息队列可以保证消息的可靠性、顺序传递、尽力交付和解耦等特性。

**面对：**

- 系统奔溃
- 服务处理能力有限
- 链路耗时长尾
- 日志如何处理

**解决方案：**

- 解耦
- 削峰
- 异步
- 日志处理

消息队列（MQ），指保存消息的一个容器，本质是某个队列。但这个队列需要支持高吞吐，高并发，并且高可用。

## 消息队列-`Kafka`

创建集群  `=>`  新增Topic  `=>`  编写生产者逻辑  `=>`  编写消费者逻辑。

`Topic`：逻辑队列，不同Topic可以建立不同的Topic。

`Cluster`：物理集群，每个集群中可以建立多个不同的Topic。

`Consumer`：消费者，负责消费Topic中的消息。

`ConsumerGroup`：消费者组，不同组Consumer消费进度互不干涉。

`Offset`：消息在Partition内的相对位置信息，可以理解为唯一ID，在Partition内部严格递增。

每个分片有多个Replica，Leader Replica将会从ISR中选出。

### Kafka架构

![image-20230209195211461](D:\文档\文本\学习笔记\typora_imag\image-20230209195211461.png)

### ZooKeeper

ZooKeeper是Kafka集群中的关键组件之一，负责存储和管理Kafka集群的元数据信息，包括Broker、Topic和分区等。ZooKeeper还用于领导者选举、故障检测和协调等重要任务。

### Producer

Producer将消息发布到Kafka集群，可以批量发送消息以提高性能。Producer将消息发送到指定的Topic，并根据分区策略选择合适的分区进行消息分发。此外，Producer还支持对消息进行压缩，以减小消息的大小，目前支持多种压缩算法。

#### Producer-批量发送

生产者可以通过批量发送消息来提高系统的性能和效率。批量发送是指将多个消息打包成一个批次，一次性发送到消息队列，而不是逐条发送。

批量发送消息的**优势**：

1. 减少网络开销：批量发送可以减少网络通信的次数，降低了网络的开销。相比于逐条发送，批量发送可以显著提高网络利用率，特别适用于高延迟或低带宽的环境。
2. 提高吞吐量：批量发送可以将多条消息合并为一个请求进行发送，减少了发送请求的开销和消耗。这样可以大幅度提高生产者的吞吐量，降低系统的延迟。
3. 降低系统开销：批量发送可以减少系统调用、锁竞争等开销，提高系统的效率和性能。对于大规模数据处理和高并发场景，批量发送尤为重要，可以有效减少资源的占用。

实现批量发送的**方法**：

1. 批量构建：生产者在发送消息之前，可先收集多个消息并将其批量构建为一个批次。这样可以减少发送请求的次数，提高网络传输效率。
2. 调整批次大小：根据系统的实际情况和性能需求，可以调整批次中消息的数量。过小的批次会增加网络开销，而过大的批次可能会增加延迟。需要根据系统的性能测试和实际场景进行权衡和调优。
3. 异步发送：生产者可以将批量发送操作放入异步线程或任务中进行处理，避免阻塞主线程。这样可以提高生产者的响应速度，同时充分利用资源进行批量发送。
4. 批量确认：消息队列系统通常提供了批量确认机制，即一次性确认多个消息的到达和处理情况。生产者可以利用批量确认机制来提高确认的效率，减少确认操作的开销。

需要注意的是，在使用批量发送时，要确保消息的**顺序**和**一致性**。对于某些业务场景，消息的顺序可能是非常重要的，因此在批量发送时需要保证消息的顺序不被打乱。

通过合理使用批量发送，可以在保证消息可靠性的前提下，提高系统的性能、吞吐量和效率。

#### Producer-数据压缩

通过压缩，减少消息大小，目前支持`Snappy`，`Gzip`，`LZ4`，`ZSTD`压缩算法。

生产者可以通过对消息进行压缩来减少消息的大小。压缩可以有效地减少网络传输的数据量，提高系统的传输效率和性能。目前许多消息队列系统都支持多种压缩算法，如Snappy、Gzip、LZ4和ZSTD等。

特点：

1. **Snappy：**Snappy是一种快速、无损的压缩算法，具有较低的压缩和解压缩延迟。它适用于需要较高的压缩速度和较低的延迟要求的场景。

2. **Gzip：**Gzip是一种广泛使用的压缩算法，具有较高的压缩比和可移植性。它适用于对数据压缩比要求较高的场景，但相对于其他算法，压缩和解压缩的速度较**慢。**

3. **LZ4：**LZ4是一种极快的压缩算法，具有非常低的压缩和解压缩延迟。它适用于对压缩速度和实时性要求较高的场景，但相对于其他算法，压缩比较低。

4. **ZSTD：**ZSTD是一种高性能的压缩算法，具有很好的压缩比和较低的压缩和解压缩延迟。它适用于对压缩比和压缩速度都有要求的场景。

需要注意：

1. **压缩算法选择：**根据实际需求和场景，选择合适的压缩算法。不同的算法在压缩比、压缩速度和解压缩速度等方面有所差异。

2. **压缩级别：**某些压缩算法（如Gzip）支持不同的压缩级别，可以根据实际情况选择适当的级别。较高的压缩级别通常会带来更高的压缩比，但也会增加压缩和解压缩的时间。

3. **CPU和内存开销：**压缩和解压缩过程需要消耗一定的CPU资源和内存空间。在选择压缩算法和压缩级别时，要考虑到系统的CPU和内存限制，避免过大的开销影响系统性能。

4. **兼容性**：在使用压缩功能时，要确保消费者能够正确解压缩消息。消费者必须支持相应的压缩算法，并能够正确处理压缩的消息。

通过合理选择和使用压缩算法，可以在减少网络传输数据量的同时，提高系统的传输效率和性能，特别是在带宽有限或数据量较大的场景下。

### Broker

Broker是Kafka集群的核心组件，负责存储和处理消息。每个Broker都是一个独立的服务器实例，存储了一个或多个Topic的消息副本。Broker维护着消息文件的结构，包括日志文件（log）、索引文件（index）、时间戳索引文件（timeindex）等。它还支持顺序写入方式，以提高写入效率。

#### Broker-数据的存储

消息队列中的消息存储通常由中间件或消息队列代理（Broker）负责。Broker在接收到生产者发送的消息后，将其持久化并存储在磁盘上，以确保消息的可靠性和持久化。

以下是消息存储的一些常见方案：

1. 日志文件存储：一种常见的消息存储方式是使用日志文件进行存储。Broker将接收到的消息追加写入日志文件中，并使用索引来记录消息的偏移量。这种方式可以提供较高的写入性能和顺序读取性能。
2. 内存映射文件存储：为了提高读取性能，一些消息队列系统采用内存映射文件存储方式。将存储在磁盘上的消息文件映射到进程的虚拟内存空间中，通过内存直接访问数据，避免了频繁的磁盘IO操作。
3. 数据库存储：一些消息队列系统使用数据库作为消息的存储介质。消息被转化为数据库中的记录，并使用适当的索引进行管理和检索。数据库存储提供了灵活的查询和管理功能，但相对于日志文件存储，可能会有更高的写入和读取延迟。
4. 消息索引：为了支持快速的消息查找和检索，消息队列系统通常使用索引结构来管理消息的偏移量和位置。常见的索引结构包括B树、跳表等。这些索引可以帮助Broker快速定位消息，并提供高效的读取和查询能力。

消息存储对于消息队列来说至关重要。一个可靠的消息存储机制可以确保消息的持久化和可靠性，防止消息丢失或重复传递。同时，存储性能、可伸缩性和容错性也是设计和选择消息存储方案时需要考虑的因素。

此外，消息队列系统通常还提供了数据备份、复制和冗余机制，以增加数据的可靠性和可用性。例如，通过主备复制、分布式存储等方式，确保即使在部分节点故障的情况下，消息仍然可靠地存储和传递。

最佳存储方案的选择应该基于具体的业务需求、性能要求和可扩展性需求进行权衡。

#### Broker-消息文件结构

数据路径：/Topic/Partition/Segment/（log|index|timeindex|...)

#### Broker-磁盘结构

移动磁头找到对应磁道，磁盘转动，找到对应扇区，最后写入。寻到成本较高，因此顺序写可以减少寻道所带来的时间成本。

#### Broker-顺序写

采用顺序写的方式进行写入，以提高写入效率。

#### Broker-如何找到消息

Consumer通过发送FetchRequest请求消息数据，Broker会将指定Offset处的消息，按照时间窗口和消息大小窗口发送给Consumer。

#### Broker偏移量索引文件

二分找到目标文件。

#### Broker时间戳索引文件

二分找到小于目标时间戳最大的索引位置，再通过寻找offset的方式找到最终数据。

#### Broker-传统数据拷贝

传统的数据拷贝是一种将数据从一个地方复制到另一个地方的方法，常用于消息队列系统中的数据传输。

在消息队列中，数据拷贝一般涉及到两个主要角色：生产者和消费者。生产者负责生成消息并发送到消息队列中，消费者则从消息队列中读取消息并进行处理。

传统的数据拷贝方法相对简单直接，但也存在一些限制和挑战。例如，数据拷贝过程通常需要依赖网络传输，可能会受到网络延迟、带宽限制等因素的影响。此外，传统的数据拷贝方式可能无法满足高并发、大规模消息传输等特殊需求。

随着技术的发展，一些消息队列系统提供了更高级的数据传输方式，如零拷贝、数据复制和复制快照等。这些方法可以提高数据传输的效率和性能，并满足更复杂的应用场景需求。

#### Broker-零拷贝

Kafka采用零拷贝机制来提高IO效率。通过操作系统级别的特性，Kafka可以直接从磁盘读取数据并发送给客户端，而无需将数据拷贝到用户空间。

### Consumer

Consumer是消息的接收端，在Kafka中有两种消费模式：Low Level和High Level。Low Level模式允许开发者手动指定每个Consumer消费哪个分区的消息。而High Level模式则由Kafka自动管理Consumer与分区之间的关系，并进行自动的负载均衡。

#### Consumer-Low Level

通过动手进行分配，哪一个Consumer消费哪一个Partition完全由业务来决定。

#### Consumer-Hign Level

消费者（Consumer）的高级概念在消息队列系统中主要指的是高级消费者API或消费者组（Consumer Group）。这些概念提供了更复杂和灵活的方式来处理消息。

1. 高级消费者API：传统的消息队列系统提供了基本的消费者API，允许消费者单独从队列中读取消息。而高级消费者API则提供了更多功能，如消息过滤、消息顺序保证、事务支持等。这使得消费者能够更好地控制消息的处理方式，并满足更复杂的业务需求。
2. 消费者组（Consumer Group）：消费者组是一组具有相同目标的消费者集合。消息队列系统将消息分发给消费者组中的一个消费者，以确保每条消息只被一个消费者处理。消费者组可以提供负载均衡和冗余处理的能力。当一个消费者出现故障或离线时，消息队列系统会自动将未处理的消息重新分配给其他消费者。

使用高级消费者API和消费者组，可以实现以下功能：

- 消息过滤：消费者可以根据特定的条件或标签过滤消息，仅处理符合条件的消息。
- 消息顺序保证：消费者可以按照消息的顺序进行处理，确保消息按照产生的顺序被消费。
- 消息事务：消费者可以在处理消息时使用事务来确保消息的可靠处理和错误回滚。
- 水平扩展：通过使用消费者组，可以将消费者分布到多个实例或节点上，以实现水平扩展和提高处理能力。

通过使用高级消费者API和消费者组，可以更好地控制消息的处理方式，并且提供了更高级的功能来应对不同的业务需求。这些功能使得消息队列系统在大规模、分布式的应用场景中更加强大和灵活。

### Consumer Rebalance

在Kafka集群中，当Consumer加入或退出时，会触发Consumer Rebalance机制。Consumer Rebalance会重新分配分区给Consumer，保证消费者消费负载的均衡性。这样可以实现高可靠性和水平扩展性。

### Kafka问题总结

1. 运维成本高
2. 对于负载不均衡的场景，解决方案复杂
3. 没有自己的缓存，完全依赖Page Cache
4. Controller和Coordinator和Broker在同一进程中，大量IO会造成其性能下降。

## 消息队列-`BMG`

兼容Kafka协议，存算分离，云原生消息队列。

架构图

![image-20230209203313561](D:\文档\文本\学习笔记\typora_imag\image-20230209203313561.png)

运维操作对比

![image-20230209203403154](D:\文档\文本\学习笔记\typora_imag\image-20230209203403154.png)

### HDFS写文件流程

随机选择一定数量的DataNode进行写入。

### Broker-Partition 状态机

![image-20230209203945905](D:\文档\文本\学习笔记\typora_imag\image-20230209203945905.png)

保证对于任意分片在同一时刻只能在一个Broker上存活。

### Broker-写文件流程

![image-20230209204043742](D:\文档\文本\学习笔记\typora_imag\image-20230209204043742.png)

### Broker-写文件 Failover

如果DataNode节点挂了或者其他原因导致我们写文件失败。

### Proxy

Proxy（代理）是一种充当客户端和服务器之间的中间层的服务器。它接收来自客户端的请求，并将这些请求转发给目标服务器，同时将响应返回给客户端。Proxy 的存在可以提供一些额外的功能和优势。

有几种常见的 Proxy 类型：

1. 反向代理：反向代理位于服务器端，客户端通过发送请求到反向代理，再由代理服务器将请求转发给目标服务器。反向代理隐藏了真实的服务器信息，提供负载均衡、缓存、SSL 加密等功能，并增加了系统的安全性和可伸缩性。
2. 正向代理：正向代理则位于客户端端，客户端通过发送请求到代理服务器，再由代理服务器将请求转发给真实的服务器。正向代理常用于绕过访问限制、保护客户端隐私、加速访问等场景。

### 多机房部署

多机房部署是指将系统资源分布在多个地理位置不同的机房中，以提高系统的可用性、容错性和用户体验。多机房部署可以应对单个机房故障、网络中断或地理位置限制等情况。

在多机房部署中，通常会使用负载均衡器（Load Balancer）来将流量分配到不同的机房。负载均衡器可以根据各个机房的负载情况、地理位置等因素，智能地选择最优的机房进行请求转发。

多机房部署还需要解决数据一致性、跨机房通信、故障恢复等问题。常见的做法包括数据复制与同步、容灾备份、跨机房通信技术（如广域网连接、虚拟专用网络等）以及监控和自动化运维工具的使用。

通过使用代理和多机房部署，可以提高系统的可扩展性、可靠性和用户体验，满足不同的业务需求和应对各种故障情况。

### 泳道消息

BOE：Bytedance Offline Environment, 是一套完全独立的线下机房环境。

PPE：Product Preview Environment， 产品预览环境。

BOE：多人同时测试，需要等待上一个人测试完成。每多一个测试人员，都需要重新搭建一个相同配置的Topic，造成人力和资源的浪费。

PPE：对于PPE的消费者来说，资源没有生产环境多，所以无法承受生产环境的流量。

解决主干泳道隔离问题以及用到资源重复创建问题。

### Databus

- 简化消息队列客户端复杂度
- 解耦业务与Topic
- 缓解集群压力，提高吞吐。

### Mirror

使用Mirror通过最终一致的方式，解决跨Region读写问题。

### Index

直接在BMQ中将数据结构化，配置索引DDL，异步构建索引后，通过Index Query服务读出数据。

### Parquet

Apache Parquet是Hadoop生态圈中一种新型列式存储格式，它可以兼容Hadoop生态圈中大多数计算框架（Hadoop，Spark等），被多种查询引擎支持（Hive，Impala，Drill等）。

直接在BMQ中将数据结构化，通过Parquet Engine，可以使用不同的方式构建Parquet格式文件。

## 消息队列-`RocketMQ`

### `RocketMQ`高级特性

#### 事务场景

在某些业务场景下，需要保证消息的可靠性传输，并且要支持事务的 ACID 特性。RocketMQ提供了事务消息的机制来满足这种需求。事务消息允许应用程序将消息发送到Broker，并在本地执行预处理操作。如果预处理操作成功，则提交事务，消息变为可消费状态；如果预处理操作失败，则回滚事务，消息被删除。

#### 事务消息

事务消息是一种具有原子性、一致性、隔离性和持久性特性的消息。RocketMQ通过`TransactionProducer`接口提供了事务消息的发送方式，开发者可以在该接口实现类中编写消息的本地事务逻辑，在执行本地事务后，根据事务的状态和结果来提交或回滚消息。

#### 延迟发送

在某些场景下，需要延迟发送消息，比如订单超时未支付的提醒通知。RocketMQ提供了延迟发送消息的功能，可以指定消息的延迟级别，从而控制消息在指定时间后才能被消费者消费。

#### 延迟消息

延迟消息是指在消息发送后，需要经过一定时间间隔后才变为可消费状态的消息。RocketMQ允许在发送消息时设置延迟级别，消息将在指定的延迟时间后才可以被消费。

#### 处理失败

在消息队列中，当消息的消费发生异常或失败时，需要一种机制来处理这些失败的消息。RocketMQ提供了处理失败消息的机制，将失败的消息发送到特定的处理队列中进行处理，以便后续的重试或人工干预。

#### 消费重试和死信队列

当消息消费失败时，RocketMQ会根据配置进行自动重试，将消息重新发送给消费者进行消费。如果重试多次后仍然失败，RocketMQ会将这些消息转移到死信队列（DLQ），供开发人员进行人工干预和处理。

## 今日总结

今天学习了消息队列的相关知识,包括消息队列的定义、应用场景、解决的问题,以及Kafka、RocketMQ、BMQ等常见消息队列中间件的基本架构、实现机制和特性。掌握了消息队列的作用是通过异步传递实现系统解耦,可以用来应对系统故障、流量削峰、数据分发等场景。了解了不同消息队列在架构设计、性能表现、功能特性等方面的区别。这为我们合理选择和应用消息队列中间件提供了基础。后续还需要继续深入学习每个消息队列的实现细节,并结合实际业务场景进行选择和应用。